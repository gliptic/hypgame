use vecmath as vec

pub let W = 32, H = 32
pub let W_SHIFT = 5, H_SHIFT = 5
pub let MAP_SECTION_SIZE = W*H;
pub let MAP_SIZE = MAP_SECTION_SIZE*3
pub let SECOND = 60
pub let MINUTE = 60 * SECOND
pub let TIME_IN_MINUTES = 1
pub let TIME_IN_SECONDS = TIME_IN_MINUTES * 60
pub let INTERVAL = 10 * SECOND
pub let FRAMES = TIME_IN_MINUTES * MINUTE
pub let STATES = FRAMES / INTERVAL
pub let VISUAL_W = 512, VISUAL_H = 512
pub let VISUAL_SIZE = VISUAL_W * VISUAL_H * 3
pub let PLAYER_RADIUS = 0.3, WALK_SPEED = 0.1
pub let CLOAK_TIME = SECOND * 30, RESET_TIMER = SECOND * 5

# TEMP
var wall_render = 0, cell_render = 0, ray_steps = 0
var wall_tests = 0, allocs = 0

@debug console.log("INTERVAL", INTERVAL)
@debug console.log("STATES", STATES)
@debug console.log("FRAMES", FRAMES)

pub let WALL_UNKNOWN = 0,
    WALL_FLOOR = 1,
    WALL_BLOCK0 = 2,
    WALL_BLOCK_MAX = WALL_BLOCK0 + 8,
    WALL_TELEPORT0 = WALL_BLOCK_MAX,
    WALL_TELEPORT_MAX = WALL_TELEPORT0 + 5*2,
    WALL_SWITCH0 = WALL_TELEPORT_MAX,
    WALL_SWITCH_MAX = WALL_SWITCH0 + 10,
    WALL_DOOR0 = WALL_SWITCH_MAX,
    WALL_DOOR_MAX = WALL_DOOR0 + 10,
    WALL_WINDOW = WALL_DOOR_MAX,
    WALL_CONFLICT = 255

@debug console.log("WALL_SWITCH0", WALL_SWITCH0)
@debug console.log("WALL_DOOR0", WALL_DOOR0)
@debug console.log("WALL_TELEPORT0", WALL_TELEPORT0)
@debug console.log("WALL_BLOCK0", WALL_BLOCK0)
@debug console.log("WALL_WINDOW", WALL_WINDOW)

pub let CELL_FLOOR = 1,
        CELL_EXIT = 3, # TODO: Bring to next level
        CELL_KEY0 = 4,
        CELL_KEY_MAX = CELL_KEY0 + 5,
        CELL_CLOAK = CELL_KEY_MAX,
        CELL_PLAYER = 0x80   # This is a special pattern only for observed_map

pub let ACTION_CHANGE = 0,
    ACTION_MOVE = 1

pub fn is_block(cell) {
    return cell >= WALL_BLOCK0 && cell < WALL_BLOCK_MAX
}

pub fn is_switch(cell) {
    return cell >= WALL_SWITCH0 && cell < WALL_SWITCH_MAX
}

pub fn is_door(cell) {
    return cell >= WALL_DOOR0 && cell < WALL_DOOR_MAX
}

pub fn is_wall(cell) {
    return is_block(cell) || is_switch(cell) || cell == WALL_WINDOW
}

pub fn is_teleport(cell) {
    return cell >= WALL_TELEPORT0 && cell < WALL_TELEPORT_MAX
}

# Cells
pub fn is_key(cell) {
    return cell >= CELL_KEY0 && cell < CELL_KEY_MAX
}

pub fn is_pickable(cell) {
    return is_key(cell)
}

fn map_create() {
    return new Uint8Array(MAP_SIZE)
}

pub fn set_cell(map, [x, y], what) {
    let prev = map[(y<<W_SHIFT) | x]
    map[(y<<W_SHIFT) | x] := what
    return prev
}

pub fn set_wall(map, [x, y], wall_dir, what) {
    let prev = map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
    map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
    return prev
}

pub fn set_wall_(map, x, y, wall_dir, what) {
    let prev = map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
    map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
    return prev
}

pub fn set_cell_(map, x, y, what) {
    let prev = map[(y<<W_SHIFT) | x]
    map[(y<<W_SHIFT) | x] := what
    return prev
}

pub fn set_observed_wall(world, time, x, y, wall_dir, what) {
    let index = time*MAP_SIZE + ((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir
    let prev = world.observed_map[index]
    if what == 0 {
        return prev
    } elseif prev && prev != what {
        if prev != WALL_CONFLICT {
            world.conflicts += 1
            world.observed_map[index] := WALL_CONFLICT
            #@debug console.log(prev, what)
        }
    } else {
        world.observed_map[index] := what
    }
    return prev
}

pub fn get_observed_wall(world, time, x, y, wall_dir) {
    let index = time*MAP_SIZE + ((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir
    return world.observed_map[index]
}

pub fn set_observed_cell(world, time, x, y, what) {
    let index = time*MAP_SIZE + ((y<<W_SHIFT) | x)
    let prev = world.observed_map[index]
    if what == 0 {
        return prev
    } elseif prev && prev != what {
        if prev != WALL_CONFLICT {
            world.conflicts += 1
            world.observed_map[index] := WALL_CONFLICT
            #@debug console.log(prev, what, x, y)
        }
    } else {
        world.observed_map[index] := what
    }
    return prev
}

pub fn get_observed_cell(world, time, x, y) {
    let index = time*MAP_SIZE + ((y<<W_SHIFT) | x)
    return world.observed_map[index]
}

pub fn get_cell(map, [x, y]) {
    return map[(y<<W_SHIFT) | x]
}

pub fn get_cell_(map, x, y) {
    return map[(y<<W_SHIFT) | x]
}

pub fn get_wall(map, [x, y], wall_dir) {
    return map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
}

pub fn get_wall_(map, x, y, wall_dir) {
    return map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
}

pub fn get_wall_mirror_(map, x, y, wall_dir) {
    return map[((x<<W_SHIFT) | y) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*(!wall_dir)]
}

pub fn get_wall_mirrorable_(map, x, y, wall_dir, mirror) {
    if mirror {
        return map[((x<<W_SHIFT) | y) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*(!wall_dir)]
    } else {
        return map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
    }
}

fn loc_from_coords([x, y]) {
    return (y<<W_SHIFT) | x
}

fn loc_from_coords_(x, y) {
    return (y<<W_SHIFT) | x
}

fn set_loc(map, loc, what) {
    map[loc] := what
}

fn get_loc(map, loc) {
    return map[loc]
}

fn set_wall_loc(map, loc, wall_dir, what) {
    map[loc + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
}

fn get_wall_loc(map, loc, wall_dir) {
    return map[loc + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
}

pub fn state_create() {
    let self = new {
        map: map_create(),
        #visual: map_create(),
        options: new {},
        prev_switches: 0,
        switches: 0,
        prev_outputs: 0,
        outputs: 0,
    }

    self.options[WALL_TELEPORT0] := new {}
    self.options[WALL_TELEPORT0]["pos_diff"] := [0, 0]
    self.options[WALL_TELEPORT0]["state_diff"] := -1
    self.options[WALL_BLOCK0 + 1] := new {}
    self.options[WALL_BLOCK0 + 1]["text"] := "OH HELLO"

    for (0..H) \y {
        for (0..W) \x {
            set_wall(self.map, [x, y], false, WALL_FLOOR)
            set_wall(self.map, [x, y], true, WALL_FLOOR)

            if x == 0 || x == W - 1 || y == 0 || y == H - 1 {
                if y == 0 || y == H - 1 {
                    set_wall(self.map, [x, y], true, WALL_BLOCK0)
                }
                if x == 0 || x == W - 1 {
                    set_wall(self.map, [x, y], false, WALL_BLOCK0)
                }
            }
            set_cell(self.map, [x, y], WALL_FLOOR)
        }
    }

    #console.log(get_wall(self.map, [31, 15], false))
    #set_wall(self.map, [31, 9], false, WALL_TELEPORT0)
    #set_wall(self.map, [31, 10], false, WALL_TELEPORT0)
    
#[=
    self.map[511] := WALL_BLOCK0
    self.map[512] := WALL_BLOCK0
    set_cell(self.map, [18, 16], WALL_BLOCK0)
    set_cell(self.map, [30, 18], WALL_BLOCK0)
    # 31, 18 not visible
=]

    @debug console.log(self.map)

    return self
}

pub fn state_preprocess(state, frame, time) {
    #[=
    for (0..MAP_SIZE) \i {
        # Modify based on state
        let cell = state.map[i]
        if is_teleport(cell) {
            let opt = state.options[cell & ~1]
            let sign = if cell & 1 { -1 } else { 1 }
            let state_diff = sign * opt["state_diff"]
            let new_time = time + state_diff * INTERVAL

            if new_time >= FRAMES || new_time < 0 {
                # TEMP
                #cell := WALL_BLOCK0
            }
        } elseif is_door(cell) {
            let door_id = cell - WALL_DOOR0
            if !(state.outputs & (1 << door_id)) {
                cell := WALL_BLOCK0
            }
        }

        state.visual[i] := cell
    }

    Object.values(frame.player_states).forEach\s {
        # TODO: Set flag on all covered cells
        if s.cloak_timer < 0 {
            set_cell(state.visual, s.pos, CELL_PLAYER)
        }
    }
    =]
}

pub fn state_update(state, frame, time) {
    let current = frame.switches
    let change_on = ~state.prev_switches & current
    let any_change = state.prev_switches != current
    state.prev_switches := current

    if any_change {
        @debug console.log("switches:", current)
    }

    #state.switches |= frame.switches

    state.prev_outputs := state.outputs
    #state.outputs := state.outputs ^ change
    state.outputs := current & (current >> 1)

    if state.prev_outputs != state.outputs {
        @debug console.log("outputs changed:", state.outputs)
    }

    

    frame.actions.forEach\[ty, a, b, c] {
        if ty == ACTION_CHANGE {
            set_loc(state.map, a, b)
        } elseif ty == ACTION_MOVE {

        }
    }
}

pub fn time_in_state(world, s) {
    return (world.offset + s * INTERVAL) % FRAMES
}

fn copy_to(from, to) {
    if Array.isArray(from) {
        to := to || []
        to.length := from.length;
        var i = 0
        while i < from.length {
            to[i] := copy_to(from[i], to[i])
            i += 1
        }
    } elseif typeof(from) === "object" {
        if from.constructor == Uint8Array {
            to := from.slice()
        } else {
            to := (to || new {})
            #Object.keys(from).forEach\k {
            for_in(from) \k{
                to[k] := copy_to(from[k], to[k])
            }
        }
    } else {
        to := from
    }

    return to
}

fn clone(obj) {
    return copy_to(obj, new {})
}

# TODO: Store world as flat array, except actions and player_states

pub fn world_reset(w) {
    w.frames := Array(FRAMES).fill(0).map({
        return new {
            switches: 0,
            actions: [],
            player_states: new {}
        }
    })
    w.observed_map.fill(0);
    w.reset_on := -1
    w.states := []
    w.offset := 0
    w.conflicts := 0
    w.current_state := 0
    w.current_player := 0
    w.current_player_state := new {
        aim: [1, 0],
        #pos: [15.5, 15.5],
        pos: [16.754003723147108, 27.054039267500432], # -0.9048064154484199 -0.42582314470137306 -0.13055117170520747 -0.991441572442059 2
        cloak_timer: -1,
        inventory: []
    }
    w.visual := new Uint8Array(VISUAL_SIZE)

    w.states.push(clone(w.first_state))
    var time = 0
    for (1..STATES) \i {
        let state = clone(w.states[w.states.length - 1])
        for (0..INTERVAL) \j {
            state_update(state, w.frames[time], time)
            time += 1
        }
        w.states.push(state)
    }

    @debug console.log(w.states)
}

pub fn world_create() {
    let w = new {
        first_state: state_create(),
        observed_map: new Uint8Array(FRAMES*MAP_SIZE)
    }

    world_reset(w)

    return w
}

fn seen_wall(world, visual_wall_id) {
    let index = visual_wall_id + VISUAL_W*VISUAL_H + 2 * (VISUAL_W / 2) * (VISUAL_H / 2)
    let prev = world.visual[index]
    world.visual[index] := 1
    return prev
}

fn seen_cell(world, visual_cell_id) {
    let index = visual_cell_id + 2 * (VISUAL_W / 2) * (VISUAL_H / 2)
    let prev = world.visual[index]
    world.visual[index] := 1
    return prev
}

fn is_sweep_obstacle(wall) {
    return is_wall(wall) || is_teleport(wall)
}

fn set_observed_wall_2(world, mirror, x, y, wall_dir, wall) {

    if !mirror {
        set_observed_wall(world, current_player_time(world), x, y, wall_dir, WALL_BLOCK0)
    } else {
        set_observed_wall(world, current_player_time(world), y, x, !wall_dir, WALL_BLOCK0)
    }
}

fn set_observed_cell_2(world, mirror, x, y, cell) {

    if !mirror {
        set_observed_cell(world, current_player_time(world), x, y, cell)
    } else {
        set_observed_cell(world, current_player_time(world), y, x, cell)
    }
}

fn test_wall(world, s, s_visual, mirror, wall_x, wall_y, wall_dir, originx, originy, stepx, slope, renders) {

    let parity = if wall_dir { Math.sign(slope) } else { stepx }
    #let stepy
    if mirror {
        let tempx = wall_x, temporg = originx
        wall_x := wall_y
        wall_y := tempx
        originx := originy
        originy := temporg
        wall_dir := !wall_dir
        #stepy := stepx
        #stepx := Math.sign(slope)
    } else {
        #stepy := Math.sign(slope)
    }

    let cur_wall = get_wall_(s_visual, wall_x, wall_y, wall_dir)
    #set_observed_wall_2(world, mirror, wall_x, wall_y, wall_dir, cur_wall)
    set_observed_wall(world, current_player_time(world), wall_x, wall_y, wall_dir, cur_wall)

    wall_tests += 1
    var r
    if is_sweep_obstacle(cur_wall) {
        let wall_end_x = wall_x + wall_dir
        let wall_end_y = wall_y + !wall_dir

        let ax = wall_x - originx
        let ay = wall_y - originy
        let bx = wall_end_x - originx
        let by = wall_end_y - originy

        allocs += 1
        r := new {
            fromx: ax,
            fromy: ay,
            tox: bx,
            toy: by,
            color: 0xffffffff,
            wall: cur_wall
        }

        if is_teleport(cur_wall) {
            r.color := 0xffff0000
            let opt = world.states[s].options[cur_wall & ~1]
            let sign = (if cur_wall & 1 { -1 } else { 1 }) * parity

            # TODO: option to block portal based on (north_south ? dir_positivex : dir_positivey)

            let pos_diffx = sign * opt["pos_diff"][0],
                pos_diffy = sign * opt["pos_diff"][1]
            let state_diff = sign * opt["state_diff"]

            if mirror {
                let temp = pos_diffx
                pos_diffx := pos_diffy
                pos_diffy := temp
            }

            r.pos_diffx := pos_diffx
            r.pos_diffy := pos_diffy
            r.s := (s + STATES + state_diff) % STATES
            r.pass := true
        }

        if renders {

            let angled_visual_wall_id = Math.floor(ay) * (VISUAL_W * 2) + Math.floor(ax) * 2 + wall_dir

            if !seen_wall(world, angled_visual_wall_id) {
                let renderer = if cur_wall == WALL_WINDOW { renders.sky } else { renders.lines }

                renderer.push(r)

                if is_teleport(cur_wall) {
                    renders.portal_texts.push(r)
                }
            }
        }
    }

    return r
}

# Abusing inline lets. Add inline functions with pass by name.
@inline let transform_with_ty = if ty {
        let pos_diffx = ty.pos_diffx,
            pos_diffy = ty.pos_diffy

        originx += pos_diffx
        originy += pos_diffy
        iposx += pos_diffx
        ipos1y += pos_diffy
        ipos2y += pos_diffy
        s := ty.s
        s_visual := world.states[s].map

        # TODO: If we're rotating direction, we need to do sweep6-kind logic
    }

fn sweep5_emu(world, s, originx, originy, dirx, diry, max_len) {
    let result = new {}, hit
    let emu_result = new {}
    if Math.abs(dirx) > Math.abs(diry) {
        hit := cast_edge(result,
            false, false,
            world, s, world.states[s].map,
            false, originx, originy, originx | 0, originy | 0,
            Math.sign(dirx), diry / Math.abs(dirx), max_len)
    } else {
        hit := cast_edge(result,
            false, false,
            world, s, world.states[s].map,
            true, originy, originx, originy | 0, originx | 0,
            Math.sign(diry), dirx / Math.abs(diry), max_len)
        let t = result.hitx
        result.hitx := result.hity
        result.hity := t
    }

    emu_result.blocked := hit && !hit.pass
    emu_result.end_s := result.s
    emu_result.end_pos := [result.hitx, result.hity]
    emu_result.end_length := result.length
    emu_result.end_wall := if hit { hit.wall } else { WALL_FLOOR }
    return emu_result
}

fn cast_edge(result,
    stop_on_hit, stop_on_vertical,
    world, s, s_visual,
    mirror, originx, originy, iposx, ipos1y,
    stepx, slope, limit, renders) {

    var cur_wall = 0
    var wall_x, wall_y
    var piposx, piposy
    var north_south, hit
    var length

    # fact = 1 / |dirx|
    # dirx = stepx / sqrt(slope^1 + 1^1)
    let fact = Math.hypot(slope, 1)

    var lim = 0
    let max_length = limit / fact

    loop {

        let dir_positivex = if stepx >= 0 { 1 } else { 0 }
        let dir_positivey = if slope >= 0 { 1 } else { 0 }
        let leapx = iposx + dir_positivex - originx
        let leapy = ipos1y + dir_positivey - originy
        let length_we = Math.abs(leapx)
        let length_ns = leapy / slope
        north_south := length_ns < length_we

        piposx := iposx
        piposy := ipos1y

        lim += 1
        if lim > 100 {
            throw((no_sweep := true), "cast_edge timeout, " + stepx + ", " + slope)
        }

        if north_south {
            wall_x := iposx
            wall_y := ipos1y + dir_positivey
            ipos1y += Math.sign(slope)
            length := length_ns
        } else {
            wall_x := iposx + dir_positivex
            wall_y := ipos1y
            iposx += stepx
            length := length_we
        }

        if stop_on_vertical && !north_south {
            # Hit vertical
            break
        }

        # TEMP: % 32
        cur_wall := test_wall(world, s, s_visual, mirror, wall_x % 32, wall_y % 32, north_south, originx, originy, stepx, slope, renders)

        if length >= max_length {
            length := max_length
            # Rewind
            iposx := piposx
            ipos1y := piposy
            break
        }

        if cur_wall {
            # Hit obstacle
            hit := cur_wall
            if stop_on_hit || !cur_wall.pass {
                break
            }
            var ipos2y = 0 # Dummy to appease the transform macro
            let ty = cur_wall
            transform_with_ty
        }
    }

    result.iposx := iposx
    result.iposy := ipos1y
    result.wall_x := wall_x
    result.wall_y := wall_y
    result.piposx := piposx
    result.piposy := piposy
    result.hitx := originx + stepx * length
    result.hity := originy + slope * length
    result.s := s
    result.north_south := north_south
    result.length := length * fact
    return hit
}

var no_sweep = false

pub fn assert(msg, condition) {
    if !condition {
        throw(no_sweep := true, "assert failed: " + msg)
    }
}

let upper = new {}, lower = new {}

pub fn cast_beam(world, ty, mirror, s, s_visual, originx, originy, iposx, ipos1y, ipos2y, stepx, slope1, slope2, limit, renders) {
    # the beam has entered the non-blocking range of cells ipos1->ipos2, inclusive
    transform_with_ty

    if (world.offset % 60) == 0 {
        #console.log(stepx, slope1, slope2)
    }

    let limit_sq = limit * limit
    
    let stepx_negative = if stepx < 0 { 1 } else { 0 }

    let upper_hit = cast_edge(upper, true, true, world, s, s_visual, mirror, originx, originy, iposx, ipos1y, stepx, slope1, limit, renders)
    let lower_hit = cast_edge(lower, true, true, world, s, s_visual, mirror, originx, originy, iposx, ipos2y, stepx, slope2, limit, renders)

    let upper_piposy = upper.piposy,
        upper_iposx = upper.iposx,
        upper_iposy = upper.iposy,
        upper_hitx = upper.hitx,
        upper_hity = upper.hity

    let lower_piposy = lower.piposy,
        lower_iposx = lower.iposx,
        lower_iposy = lower.iposy,
        lower_hitx = lower.hitx,
        lower_hity = lower.hity

    let x = iposx + stepx
    var y1 = Math.max(upper_iposy, upper_piposy), y2 = Math.min(lower_iposy, lower_piposy)

    if upper_hit {
        let w = upper_hit

        if w.pass && upper_iposy < y1 {
            # Beam up
            #set_observed_wall_2(world, mirror, upper.wall_x, upper.wall_y, upper.north_south, WALL_BLOCK0) # TEMP
            let cut_x = x + stepx_negative

            if lower_hit && lower_iposy < y1 {
                # Lower hits upwards too
                cut_x := stepx * Math.min(stepx * cut_x, stepx * lower_hitx)
            }

            let new_slope2 = (y1 - originy) / Math.abs(cut_x - originx)

            cast_beam(
                world, w, mirror, s, s_visual,
                originx, originy,
                upper_iposx, upper_iposy, upper_iposy,
                stepx, slope1, new_slope2,
                limit,
                renders)
        }
    }

    if lower_hit {
        let w = lower_hit

        if w.pass && lower_iposy > y2 {
            # Beam down
            #set_observed_wall_2(world, mirror, lower.wall_x, lower.wall_y, lower.north_south, WALL_BLOCK0) # TEMP
            let cut_x = x + stepx_negative
            if upper_hit && upper_iposy > y2 {
                # Upper hits downwards too
                cut_x := stepx * Math.min(stepx * cut_x, stepx * upper_hitx)
            }

            let new_slope1 = (y2 + 1 - originy) / Math.abs(cut_x - originx)
            
            cast_beam(
                world, w, mirror, s, s_visual,
                originx, originy,
                lower_iposx, lower_iposy, lower_iposy,
                stepx, new_slope1, slope2,
                limit,
                renders)
        }
    }

    var beginy = y1
    var rangety
    var cur_obstacle = false
    var wallty = new { pass: false } # TODO: Move

    let time = time_in_state(world, s)
    for (Math.min(y1, ipos1y)..Math.max(y2, ipos2y) + 1) \y {
        # TODO: Render objects in these
        var local_originx = if mirror { originy } else { originx },
            local_originy = if mirror { originx } else { originy }
        let local_y = if mirror { iposx } else { y }
        let local_x = if mirror { y } else { iposx }
        var cur_cell = get_cell_(s_visual, local_x, local_y)
        if is_key(cur_cell) {
            renders.objects.push(new {
                x: local_x + 0.5 - local_originx,
                y: local_y + 0.5 - local_originy,
                color: 0xff00ffff
            })
        } elseif cur_cell == CELL_EXIT {
            renders.objects.push(new {
                x: local_x + 0.5 - local_originx,
                y: local_y + 0.5 - local_originy,
                color: 0xffffff00
            })
        } elseif cur_cell == CELL_CLOAK {
            renders.objects.push(new {
                x: local_x + 0.5 - local_originx,
                y: local_y + 0.5 - local_originy,
                color: 0xffaaaaaa
            })
        }

        let player_states = world.frames[time].player_states
        for_in(player_states) \k {
            let p = player_states[k]
        #}
        #Object.values(world.frames[time].player_states).forEach\p {
            if (local_x == (p.pos[0] | 0) &&
                local_y == (p.pos[1] | 0) &&
                p.cloak_timer < 0) {

                # TODO: Check if we've rendered player id at visual_cell_id
                renders.lines.push(new {
                    #from: vec.vsub2(p.pos, [local_originx, local_originy]),
                    fromx: p.pos[0] - local_originx,
                    fromy: p.pos[1] - local_originy,
                    #to: vec.vsub2(vec.vadd2(p.pos, p.aim), [local_originx, local_originy]),
                    tox: p.pos[0] + p.aim[0] - local_originx,
                    toy: p.pos[1] + p.aim[1] - local_originy,
                    color: 0xff0000ff
                    #trans: composite_transform
                })

                cur_cell |= CELL_PLAYER
            }
        }

        set_observed_cell(world, time, local_x, local_y, cur_cell)
    }

    for (y1..y2 + 2) \y {
        let next, next_obstacle
        let cut = y == y2 + 1
        if !cut {

            let xdiff = x + stepx_negative - originx,
                ydiff1 = y - originy,
                ydiff2 = y + 1 - originy,
                xdiff_sq = xdiff * xdiff,
                dist1_sq = xdiff_sq + ydiff1 * ydiff1,
                dist2_sq = xdiff_sq + ydiff2 * ydiff2

            if dist1_sq > limit_sq && dist2_sq > limit_sq {
                next := wallty
                #next_obstacle := true
            } else {
                next := test_wall(world, s, s_visual, mirror, x + stepx_negative, y, false, originx, originy, stepx, 0, renders)
                #next_obstacle := is_sweep_obstacle(next)
            }

            cut := ! !next || cur_obstacle
            if !cut && y != y1 {
                #set_observed_wall_2(world, mirror, x, y, true, WALL_BLOCK0)
                # TODO: Simplified test_wall? We don't need much of the functionality
                cut := ! !test_wall(world, s, s_visual, mirror, x, y, true, originx, originy, 0, 0)
            }
        }

        if cut {
            let endy = y
            if (world.offset % 60) == 0 {
                #console.log("rangety", rangety)
            }
            if beginy < endy && (!rangety || rangety.pass) {

                let new_dir1x = x + stepx_negative - originx
                let new_dir1y = Math.max(beginy, upper_hity) - originy
                let new_dir2x = x + stepx_negative - originx
                let new_dir2y = Math.min(endy, lower_hity) - originy

                if new_dir1y < new_dir2y {
                    let new_slope1 = new_dir1y / Math.abs(new_dir1x)
                    let new_slope2 = new_dir2y / Math.abs(new_dir2x)

#[=
                    if is_teleport(rangety) { # TEMP
                        for (beginy..endy) \wally {
                            set_observed_wall_2(world, mirror, x + stepx_negative, wally, false, WALL_BLOCK0)
                        }
                    }
                    =]

                    cast_beam(
                        world, rangety, mirror, s, s_visual,
                        originx, originy,
                        x, beginy, endy - 1,
                        stepx, new_slope1, new_slope2,
                        limit,
                        renders)
                }
            }
            beginy := y
            rangety := next
        }

        cur_obstacle := ! !next
    }
}

pub fn sweep6(world, mirror, s, originx, originy, dir1x, dir1y, dir2x, dir2y, max_len, renders) {
    if no_sweep { return }

    var iposx = originx | 0;
    var iposy = originy | 0;
    #var ipos2x = originx | 0;
    #var ipos2y = originy | 0;

    let s_visual = world.states[s].map
    let limit = 64
    var k = 0
    var thresh = 0.01
    if dir1x >= thresh && dir2x >= thresh {
        cast_beam(world, undefined, mirror, s, s_visual, originx, originy, iposx, iposy, iposy, 1, dir1y / Math.abs(dir1x), dir2y / Math.abs(dir2x), limit, renders)
        k := 1
    } elseif dir1x <= -thresh && dir2x <= -thresh {
        cast_beam(world, undefined, mirror, s, s_visual, originx, originy, iposx, iposy, iposy, -1, dir2y / Math.abs(dir2x), dir1y / Math.abs(dir1x), limit, renders)
        k := 2
    } elseif dir1y >= thresh && dir2y >= thresh {
        cast_beam(world, undefined, !mirror, s, s_visual, originy, originx, iposy, iposx, iposx, 1, dir2x / Math.abs(dir2y), dir1x / Math.abs(dir1y), limit, renders)
        k := 3
    } elseif dir1y <= thresh && dir2y <= thresh {
        cast_beam(world, undefined, !mirror, s, s_visual, originy, originx, iposy, iposx, iposx, -1, dir1x / Math.abs(dir1y), dir2x / Math.abs(dir2y), limit, renders)
        k := 4
    }

    @debug if (world.offset % 60) == 0 {
        console.log(originx, originy, dir1x, dir1y, dir2x, dir2y, k)
    }
}

pub fn sweep5(world, s, originx, originy, dirx, diry, max_len, renders) {
    var iposx = originx | 0
    var iposy = originy | 0
    #var pipos = ipos
    var piposx = iposx, piposy = iposy
    var blocked = true
    var safe_counter = 0
    var length = 0
    #var composite_transform = [1, 0, 0, 1]
    var cur_wall
    var visual_wall_id = 0

    let div_start_x, div_start_y, north_south
    let s_visual = world.states[s].visual

    let inv_divx = 1 / dirx
    let inv_divy = 1 / diry

    loop {
        #[=
        safe_counter += 1
        if safe_counter > 100 {
            break
        }
        =]

        ray_steps += 1

        @debug if iposx < 0 || iposy < 0 || iposx >= W || iposy >= H {
            #@debug console.log("err")
            break
        }

        let visual_cell_id = visual_wall_id >> 1

        if renders && !seen_cell(world, visual_cell_id) {
            cell_render += 1

            let cur_cell = get_cell_(s_visual, iposx, iposy)
            let time = time_in_state(world, s)
            if cur_cell == CELL_PLAYER {
                
                Object.values(world.frames[time].player_states).forEach\p {
                    if (iposx == (p.pos[0] | 0) &&
                        iposy == (p.pos[1] | 0) &&
                        p.cloak_timer < 0) {

                        # TODO: Check if we've rendered player id at visual_cell_id
                        renders.lines.push(new {
                            #from: vec.vsub2(p.pos, [originx, originy]),
                            fromx: p.pos[0] - originx,
                            fromy: p.pos[1] - originy,
                            #to: vec.vsub2(vec.vadd2(p.pos, p.aim), [originx, originy]),
                            tox: p.pos[0] + p.aim[0] - originx,
                            toy: p.pos[1] + p.aim[1] - originy,
                            color: 0xff0000ff
                            #trans: composite_transform
                        })
                    }
                }
            } elseif is_key(cur_cell) {
                let p = [iposx + 0.5, iposy + 0.5]
                renders.lines.push(new {
                    fromx: iposx - originx,
                    fromy: iposy + 0.5 - originy,
                    tox: iposx + 1.0 - originx,
                    toy: iposy + 0.5 - originy,
                    #to: vec.vsub2([iposx + 1, iposy + 0.5], [originx, originy]),
                    color: 0xff00ffff
                    #trans: composite_transform
                })
            } elseif cur_cell == CELL_EXIT {
                let p = [iposx + 0.5, iposy + 0.5]
                renders.lines.push(new {
                    fromx: iposx - originx,
                    fromy: iposy + 0.5 - originy,
                    tox: iposx + 1.0 - originx,
                    toy: iposy + 0.5 - originy,
                    color: 0xffffff00
                    #trans: composite_transform
                })
            } elseif cur_cell == CELL_CLOAK {
                #[=
                let p = [iposx + 0.5, iposy + 0.5]
                renders.lines.push(new {
                    fromx: iposx - originx,
                    fromy: iposy + 0.5 - originy,
                    tox: iposx + 1.0 - originx,
                    toy: iposy + 0.5 - originy,
                    color: 0xffaaaaaa
                    #trans: composite_transform
                })
                =]

                renders.objects.push(new {
                    x: iposx + 0.5,
                    y: iposy + 0.5,
                    color: 0xffaaaaaa
                })
                
            }
            
            # TODO: Check for conflict with map
            set_observed_cell(world, time, iposx, iposy, cur_cell)
        }


        #let dir_positive = [dirx, diry].map\v { if v >= 0 { return 1 } else { return 0 }}
        let dir_positivex = if dirx >= 0 { 1 } else { 0 }
        let dir_positivey = if diry >= 0 { 1 } else { 0 }
        #let leap = vec.vadd2(vec.vsub2(ipos, [originx, originy]), dir_positive)
        let leapx = iposx - originx + dir_positivex
        let leapy = iposy - originy + dir_positivey
        #let length_we = leap[0] / dirx
        #let length_ns = leap[1] / diry
        let length_we = leapx * inv_divx #/ dirx TEMP Need to update inv
        let length_ns = leapy * inv_divy #/ diry
        north_south := length_ns < length_we

        #pipos := ipos
        piposx := iposx
        piposy := iposy

        #let div_start_x = ipos[0], div_start_y = ipos[1]
        
        if north_south {
            #ipos := vec.vadd2(ipos, [0, Math.sign(diry)])
            iposy += Math.sign(diry)
            visual_wall_id += Math.sign(diry) * (VISUAL_W * 2)
            div_start_x := iposx
            div_start_y := piposy + dir_positivey
            length := length_ns
        } else {
            #ipos := vec.vadd2(ipos, [Math.sign(dirx), 0])
            iposx += Math.sign(dirx)
            visual_wall_id += Math.sign(dirx) * 2
            div_start_x := piposx + dir_positivex
            div_start_y := iposy
            length := length_we
        }
        
        cur_wall := get_wall_(s_visual, div_start_x, div_start_y, north_south)

        if length >= max_len {
            length := max_len
            blocked := false
            break
        }


        if is_wall(cur_wall) {
            let angled_visual_wall_id = visual_wall_id + north_south
            let div_endx = div_start_x + north_south
            let div_endy = div_start_y + !north_south

            # Line is divider between pipos <-> ipos

            #if record && !set_wall(world.states[s].visual, div_start, north_south, 1) {
            if renders && !seen_wall(world, angled_visual_wall_id) {

                wall_render += 1

                # from/to can be used for sky vectors
                # trans * from/to is where to render
                let renderer = if cur_wall == WALL_WINDOW { renders.sky } else { renders.lines }

                let ax = div_start_x - originx
                let ay = div_start_y - originy
                let bx = div_endx - originx
                let by = div_endy - originy

                let swap = if north_south { dir_positivey } else { !dir_positivex }

                if swap {
                    let tempx = ax, tempy = ay
                    ax := bx
                    ay := by
                    bx := tempx
                    by := tempy
                }

                #let a = vec.vsub2([div_start_x, div_start_y], [originx, originy]),
                #    b = vec.vsub2([div_endx, div_endy], [originx, originy])
                renderer.push(new {
                    fromx: ax,
                    fromy: ay,
                    tox: bx,
                    toy: by,
                    color: if is_switch(cur_wall) { 0xffffff00 } else { 0xffffffff },
                    #trans: composite_transform,
                    s
                })

                let opt = world.states[s].options[cur_wall]
                if opt && opt["text"] {
                    # TODO: Apply this to all lines somehow
                    #let a = vec.vsub2([div_start_x, div_start_y], [originx, originy])
                    #let b = vec.vsub2([div_endx, div_endy], [originx, originy])
                    

                    renders.portal_texts.push(new {
                        fromx: ax,
                        fromy: ay,
                        tox: bx,
                        toy: by,
                        color: 0xffff0000,
                        text: opt["text"]
                        #trans: composite_transform
                    })
                }

                let time = time_in_state(world, s)

                # TODO: Check for conflict with map
                set_observed_wall(world, time, div_start_x, div_start_y, north_south, cur_wall)
            }

            break
        } elseif is_teleport(cur_wall) {
            let angled_visual_wall_id = visual_wall_id + north_south
            let div_endx = div_start_x + north_south
            let div_endy = div_start_y + !north_south

            let opt = world.states[s].options[cur_wall & ~1]
            let sign = (if cur_wall & 1 { -1 } else { 1 }) * (if north_south { Math.sign(diry) } else { Math.sign(dirx) })

            # TODO: option to block portal based on (north_south ? dir_positivex : dir_positivey)

            let pos_diffx = sign * opt["pos_diff"][0],
                pos_diffy = sign * opt["pos_diff"][1]
            let state_diff = sign * opt["state_diff"]
            # TODO: Check if (time + state_diff * INTERVAL) is outside
            # time. If so, render wall and break

            if renders && !seen_wall(world, angled_visual_wall_id) {

                #let a = vec.vsub2([div_start_x, div_start_y], [originx, originy])
                let ax = div_start_x - originx
                let ay = div_start_y - originy
                #let b = vec.vsub2([div_endx, div_endy], [originx, originy])
                let bx = div_endx - originx
                let by = div_endy - originy

                renders.lines.push(new {
                    #from: vec.vsub2([div_start_x, div_start_y], [originx, originy]),
                    fromx: ax,
                    fromy: ay,
                    #to: vec.vsub2([div_endx, div_endy], [originx, originy]),
                    tox: bx,
                    toy: by,
                    color: 0xffff0000
                    #trans: composite_transform
                })

                # TODO: Apply this to all lines somehow
                let swap = if north_south { dir_positivey } else { !dir_positivex }
                
                if swap {
                    let tempx = ax, tempy = ay
                    ax := bx
                    ay := by
                    bx := tempx
                    by := tempy
                }

                renders.portal_texts.push(new {
                    fromx: ax,
                    fromy: ay,
                    tox: bx,
                    toy: by,
                    color: 0xffff0000
                    #trans: composite_transform
                })
            }

            #ipos := vec.vsub2(vec.vadd2(ipos, pos_diff), dir_positive)
            iposx := iposx + pos_diffx - dir_positivex
            iposy := iposy + pos_diffy - dir_positivey
            originx += pos_diffx
            originy += pos_diffy
            let linedx = dirx * length
            let linedy = diry * length
            # [originx, originy] := vec.vsub2(vec.vadd2([originx, originy], lined), lined) # TODO: Mult with trans
            originx := (originx + linedx) - linedx
            originy := (originy + linedy) - linedy
            #originx -= originx + linedx
            #originy -= originy + linedy
            # TODO: [dirx, diry] = trans * [dirx, diry];
            # TODO: change inv* too

            #ipos := vec.vadd2(ipos, [dirx, diry].map\v { if v >= 0.0 { return 1 } else { return 0 }})
            iposx := iposx + if dirx >= 0 { 1 } else { 0 }
            iposy := iposy + if diry >= 0 { 1 } else { 0 }
            s := (s + STATES + state_diff) % STATES
            s_visual := world.states[s].visual
        }

        #[=
        let cur_cell = get_cell(world.states[s].map, ipos)
        let prev_visual = set_cell(world.states[s].visual, ipos, 1)
        
        if record {
            if !prev_visual && is_wall(cur_cell) {
                #console.log(ipos, vec.vsub2(ipos, [originx, originy]))
                renders.push(new {
                    ul: vec.vsub2(ipos, [originx, originy]),
                    trans: composite_transform
                })
                let time = time_in_state(world, s)
                set_cell(world.frames[time].observed_map, ipos, cur_cell)
            }
        }

        =]
#[=
        if is_wall(cur_cell) {
            break
        }
=]
    }

    return new {
        origin: [originx, originy],
        blocked,
        end_s: s,
        end_pos: vec.vadd2([originx, originy], vec.vmul2([dirx, diry], length)),
        end_ipos: [iposx, iposy],
        end_div_start: [div_start_x, div_start_y],
        end_ns: north_south,
        end_wall: cur_wall,
        end_length: length
        #trans: composite_transform
    }
}

fn sweep(world, origin, aim, renders) {
    world.visual.fill(0)

    let fov = 1
    let fov_vec = [Math.cos(fov / 2), Math.sin(fov / 2)]

    let first = vec.vrotate(aim, [fov_vec[0], -fov_vec[1]])
    let second = vec.vrotate(aim, fov_vec)
    let diff = vec.vsub2(second, first)
    var i = 0
#[=
    if false {
        let rays = 512
        #let rays = 100
        while i < rays {
            let m = vec.vadd2(first, vec.vmul2(diff, (i / rays)))
            m := vec.vmul2(m, 1 / Math.hypot(m[0], m[1]))
            sweep5(world, world.current_state, origin[0], origin[1], m[0], m[1], 64, renders)
            i += 1
        }
    } else {
    =]
    sweep6(world, false, world.current_state, origin[0], origin[1], first[0], first[1], second[0], second[1], 64, renders)
}

pub fn current_player_time(world) {
    return time_in_state(world, world.current_state)
}

pub fn world_update(world, action, renders, paused) {

    if !paused {
        for (0..STATES) \s {
            let time = time_in_state(world, s)
            state_update(world.states[s], world.frames[time], time)
            if time == FRAMES - 1 {
                if world.current_state == s {
                    # We're here, we'll die :(
                    world.current_player += 1 # For now, just "rebirth" as new player
                }
                world.states[s] := clone(world.first_state)
            }
        }
    }

    var switch_ons = 0

    world.current_player_state.aim := action.aim;
    if action.act {
        let act_result = sweep5_emu(world, world.current_state,
            world.current_player_state.pos[0]
            world.current_player_state.pos[1],
            action.aim[0],
            action.aim[1],
            1)
        if act_result.blocked {
            if is_switch(act_result.end_wall) {
                let opt = world.states[world.current_state].options[act_result.end_wall]
                let ok = false
                if opt && opt.required_key {
                    if world.current_player_state.inventory[opt.required_key] {
                        world.current_player_state.inventory[opt.required_key] -= 1
                        ok := true
                    }
                }

                if ok {
                    #@debug console.log("activated", act_result.end_div_start, act_result.end_ns)
                    let switch_id = act_result.end_wall - WALL_SWITCH0
                    #world.states[world.current_state].switches |= 1 << switch_id
                    switch_ons |= 1 << switch_id
                    @debug console.log("switched")
                } else {
                    # TODO: Play denied sound
                    @debug console.log("denied")
                }
            }
        } else {
            #@debug console.log("found nothing")
        }
    }

    if action.walk[0] || action.walk[1] {
        let pi = world.current_player_state.pos
        let walk_dir = vec.vnormalize2(action.walk)

        let result = sweep5_emu(world, world.current_state,
            world.current_player_state.pos[0],
            world.current_player_state.pos[1],
            walk_dir[0],
            walk_dir[1],
            WALK_SPEED)

        if !result.blocked {
            let time = current_player_time(world)
            if time_in_state(world, result.end_s) < time {
                @debug console.log("going back to", time_in_state(world, result.end_s))
                world.current_player += 1
            }
            # TEMP!
            if time_in_state(world, result.end_s) != time {
                world.current_player += 1
            }
            world.current_state := result.end_s
            world.current_player_state.pos := result.end_pos;

            # TODO: 
            #world.current_player_state.aim = result.trans.transpose() * self.current_player_state.aim;
        }

        var ang = 0, min_dist = 10, min_dir
        while ang < Math.PI*2 {
            let dir = [Math.cos(ang), Math.sin(ang)]
            let res = sweep5_emu(world, world.current_state,
                world.current_player_state.pos[0],
                world.current_player_state.pos[1],
                dir[0],
                dir[1],
                PLAYER_RADIUS)
            if res.blocked && res.end_length < min_dist {
                min_dist := res.end_length
                min_dir := dir
            }
            ang += 0.2
        }

        if min_dir {
            world.current_player_state.pos := vec.vsub2(
                world.current_player_state.pos,
                vec.vmul2(min_dir, (PLAYER_RADIUS - min_dist)))
        }

        # TODO: If standing on e.g. a cloak crystal, reset cloak timer
        # Pick up items and insert
        let at = loc_from_coords(world.current_player_state.pos)
        let on_cell = get_loc(world.states[world.current_state].map, at)
        if on_cell == CELL_EXIT {
            if world.reset_on < 0 {
                world.reset_on := world.offset + RESET_TIMER
                # TODO: Increment level
            }
        } elseif on_cell == CELL_CLOAK {
            world.current_player_state.cloak_timer := CLOAK_TIME
        } elseif is_pickable(on_cell) {
            let time = current_player_time(world);
            world.current_player_state.inventory[on_cell] |= 1
            let to = CELL_FLOOR
            set_loc(world.states[world.current_state].map, at, to)
            world.frames[time].actions.push([ ACTION_CHANGE, at, to ])

            @debug console.log("current inventory:", world.current_player_state.inventory)
        }
    }

    world.current_player_state.cloak_timer -= 1

    if !paused {
        world.offset += 1
    }

    let now = current_player_time(world)
    world.frames[now].player_states[world.current_player] :=
        clone(world.current_player_state)
    # Record switch activations by current player
    world.frames[now].switches |= switch_ons

    let origin = world.current_player_state.pos
    let aim = world.current_player_state.aim
    for (0..STATES) \s {
        let time = time_in_state(world, s)
        # Set visual map
        state_preprocess(world.states[s], world.frames[time], time)
    }
    let prev_conflicts = world.conflicts
    sweep(world, origin, aim, renders)
    #if world.conflicts != prev_conflicts && !paused {  # TEMP
    if false {
        # Violation
        if get_observed_cell(world, now, world.current_player_state.pos[0] | 0, world.current_player_state.pos[1] | 0) != CELL_PLAYER {
            # TODO: Try past locations first
            for (0..20) \i {
                world.current_player_state.pos := [Math.random() * 31, Math.random() * 31]
                let dest = get_observed_cell(world, now, world.current_player_state.pos[0], world.current_player_state.pos[1])
                if dest == 0 || dest == CELL_PLAYER {
                    break
                }
            }
            # Write new player state
            world.frames[now].player_states[world.current_player] :=
                clone(world.current_player_state)
        } else {
            # Violation is likely that we saw something we shouldn't
            # One way to fix is to blind the player
        }
    }

    if world.offset == world.reset_on {
        world_reset(world)
    }

    if !paused && (now % SECOND) == 0 {
        let seconds = (now / SECOND)
        @debug console.log((seconds / 60) | 0, seconds % 60, "player ", world.current_player)
        @debug console.log("renders:", wall_tests, allocs)
        wall_tests := 0
        wall_render := 0
        cell_render := 0
        ray_steps := 0
        allocs := 0
    }
}
