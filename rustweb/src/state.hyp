use vecmath as vec

pub let W = 32, H = 32
pub let W_SHIFT = 5, H_SHIFT = 5
pub let MAP_SECTION_SIZE = W*H;
pub let MAP_SIZE = MAP_SECTION_SIZE*3
pub let SECOND = 60
pub let MINUTE = 60 * SECOND
pub let TIME_IN_MINUTES = 1
pub let TIME_IN_SECONDS = TIME_IN_MINUTES * 60
pub let INTERVAL = 10 * SECOND
pub let FRAMES = TIME_IN_MINUTES * MINUTE
pub let STATES = FRAMES / INTERVAL
pub let VISUAL_W = 512, VISUAL_H = 512
pub let VISUAL_SIZE = VISUAL_W * VISUAL_H * 3
pub let PLAYER_RADIUS = 0.3, WALK_SPEED = 0.1
pub let CLOAK_TIME = SECOND * 30, RESET_TIMER = SECOND * 5

# TEMP
var wall_render = 0, cell_render = 0, ray_steps = 0

@debug console.log("INTERVAL", INTERVAL)
@debug console.log("STATES", STATES)
@debug console.log("FRAMES", FRAMES)

pub let WALL_FLOOR = 1,
    WALL_BLOCK0 = 2,
    WALL_BLOCK_MAX = WALL_BLOCK0 + 8,
    WALL_TELEPORT0 = WALL_BLOCK_MAX,
    WALL_TELEPORT_MAX = WALL_TELEPORT0 + 5*2,
    WALL_SWITCH0 = WALL_TELEPORT_MAX,
    WALL_SWITCH_MAX = WALL_SWITCH0 + 10,
    WALL_DOOR0 = WALL_SWITCH_MAX,
    WALL_DOOR_MAX = WALL_DOOR0 + 10,
    WALL_WINDOW = WALL_DOOR_MAX,
    WALL_CONFLICT = 255

@debug console.log("WALL_SWITCH0", WALL_SWITCH0)
@debug console.log("WALL_DOOR0", WALL_DOOR0)
@debug console.log("WALL_TELEPORT0", WALL_TELEPORT0)
@debug console.log("WALL_BLOCK0", WALL_BLOCK0)
@debug console.log("WALL_WINDOW", WALL_WINDOW)

pub let CELL_FLOOR = 1,
        CELL_PLAYER = 2,
        CELL_EXIT = 3, # TODO: Bring to next level
        CELL_KEY0 = 4,
        CELL_KEY_MAX = CELL_KEY0 + 5,
        CELL_CLOAK = CELL_KEY_MAX

pub let ACTION_CHANGE = 0,
    ACTION_MOVE = 1

pub fn is_block(cell) {
    return cell >= WALL_BLOCK0 && cell < WALL_BLOCK_MAX
}

pub fn is_switch(cell) {
    return cell >= WALL_SWITCH0 && cell < WALL_SWITCH_MAX
}

pub fn is_door(cell) {
    return cell >= WALL_DOOR0 && cell < WALL_DOOR_MAX
}

pub fn is_wall(cell) {
    return is_block(cell) || is_switch(cell) || cell == WALL_WINDOW
}

pub fn is_teleport(cell) {
    return cell >= WALL_TELEPORT0 && cell < WALL_TELEPORT_MAX
}

# Cells
pub fn is_key(cell) {
    return cell >= CELL_KEY0 && cell < CELL_KEY_MAX
}

pub fn is_pickable(cell) {
    return is_key(cell)
}

fn map_create() {
    return new Uint8Array(MAP_SIZE)
}

pub fn set_cell(map, [x, y], what) {
    let prev = map[(y<<W_SHIFT) | x]
    map[(y<<W_SHIFT) | x] := what
    return prev
}

pub fn set_wall(map, [x, y], wall_dir, what) {
    let prev = map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
    map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
    return prev
}

pub fn set_wall_(map, x, y, wall_dir, what) {
    let prev = map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
    map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
    return prev
}

pub fn set_cell_(map, x, y, what) {
    let prev = map[(y<<W_SHIFT) | x]
    map[(y<<W_SHIFT) | x] := what
    return prev
}

pub fn set_observed_wall(world, time, x, y, wall_dir, what) {
    let index = time*MAP_SIZE + ((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir
    let prev = world.observed_map[index]
    if what == 0 {
        return prev
    } else if prev && prev != what {
        if prev != WALL_CONFLICT {
            world.conflicts += 1
            world.observed_map[index] := WALL_CONFLICT
            #@debug console.log(prev, what)
        }
    } else {
        world.observed_map[index] := what
    }
    return prev
}

pub fn get_observed_wall(world, time, x, y, wall_dir) {
    let index = time*MAP_SIZE + ((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir
    return world.observed_map[index]
}

pub fn set_observed_cell(world, time, x, y, what) {
    let index = time*MAP_SIZE + ((y<<W_SHIFT) | x)
    let prev = world.observed_map[index]
    if what == 0 {
        return prev
    } else if prev && prev != what {
        if prev != WALL_CONFLICT {
            world.conflicts += 1
            world.observed_map[index] := WALL_CONFLICT
            #@debug console.log(prev, what, x, y)
        }
    } else {
        world.observed_map[index] := what
    }
    return prev
}

pub fn get_observed_cell(world, time, x, y) {
    let index = time*MAP_SIZE + ((y<<W_SHIFT) | x)
    return world.observed_map[index]
}

pub fn get_cell(map, [x, y]) {
    return map[(y<<W_SHIFT) | x]
}

pub fn get_cell_(map, x, y) {
    return map[(y<<W_SHIFT) | x]
}

pub fn get_wall(map, [x, y], wall_dir) {
    return map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
}

pub fn get_wall_(map, x, y, wall_dir) {
    return map[((y<<W_SHIFT) | x) + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
}

fn loc_from_coords([x, y]) {
    return (y<<W_SHIFT) | x
}

fn loc_from_coords_(x, y) {
    return (y<<W_SHIFT) | x
}

fn set_loc(map, loc, what) {
    map[loc] := what
}

fn get_loc(map, loc) {
    return map[loc]
}

fn set_wall_loc(map, loc, wall_dir, what) {
    map[loc + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
}

fn get_wall_loc(map, loc, wall_dir) {
    return map[loc + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
}

pub fn state_create() {
    let self = new {
        map: map_create(),
        visual: map_create(),
        options: new {},
        prev_switches: 0,
        switches: 0,
        prev_outputs: 0,
        outputs: 0,
    }

    self.options[WALL_TELEPORT0] := new {}
    self.options[WALL_TELEPORT0]["pos_diff"] := [-31, 0]
    self.options[WALL_TELEPORT0]["state_diff"] := -1
    self.options[WALL_BLOCK0 + 1] := new {}
    self.options[WALL_BLOCK0 + 1]["text"] := "OH HELLO"

    for y in 0..H {
        for x in 0..W {
            set_wall(self.map, [x, y], false, WALL_FLOOR)
            set_wall(self.map, [x, y], true, WALL_FLOOR)

            if x == 0 || x == W - 1 || y == 0 || y == H - 1 {
                if y == 0 || y == H - 1 {
                    set_wall(self.map, [x, y], true, WALL_BLOCK0)
                }
                if x == 0 || x == W - 1 {
                    set_wall(self.map, [x, y], false, WALL_BLOCK0)
                }
            }
            set_cell(self.map, [x, y], WALL_FLOOR)
        }
    }

    #console.log(get_wall(self.map, [31, 15], false))
    #set_wall(self.map, [31, 9], false, WALL_TELEPORT0)
    #set_wall(self.map, [31, 10], false, WALL_TELEPORT0)
    
#[=
    self.map[511] := WALL_BLOCK0
    self.map[512] := WALL_BLOCK0
    set_cell(self.map, [18, 16], WALL_BLOCK0)
    set_cell(self.map, [30, 18], WALL_BLOCK0)
    # 31, 18 not visible
=]

    @debug console.log(self.map)

    return self
}

pub fn state_preprocess(state, frame, time) {
    for i in 0..MAP_SIZE {
        # Modify based on state
        let cell = state.map[i]
        if is_teleport(cell) {
            let opt = state.options[cell & ~1]
            let sign = if cell & 1 { -1 } else { 1 }
            let state_diff = sign * opt["state_diff"]
            let new_time = time + state_diff * INTERVAL

            if new_time >= FRAMES || new_time < 0 {
                cell := WALL_BLOCK0
            }
        } else if is_door(cell) {
            let door_id = cell - WALL_DOOR0
            if !(state.outputs & (1 << door_id)) {
                cell := WALL_BLOCK0
            }
        }

        state.visual[i] := cell
    }

    Object.values(frame.player_states).forEach({ |s|
        # TODO: Set flag on all covered cells
        if s.cloak_timer < 0 {
            set_cell(state.visual, s.pos, CELL_PLAYER)
        }
    })
}

pub fn state_update(state, frame, time) {
    let current = frame.switches
    let change_on = ~state.prev_switches & current
    let any_change = state.prev_switches != current
    state.prev_switches := current

    if any_change {
        @debug console.log("switches:", current)
    }

    #state.switches |= frame.switches

    state.prev_outputs := state.outputs
    #state.outputs := state.outputs ^ change
    state.outputs := current & (current >> 1)

    if state.prev_outputs != state.outputs {
        @debug console.log("outputs changed:", state.outputs)
    }

    

    frame.actions.forEach({ |[ty, a, b, c]|
        if (ty == ACTION_CHANGE) {
            set_loc(state.map, a, b)
        } else if (ty == ACTION_MOVE) {

        }
    })
}

fn time_in_state(world, s) {
    return (world.offset + s * INTERVAL) % FRAMES
}

fn copy_to(from, to) {
    if (from.constructor == Uint8Array) {
        to := from.slice()
    } else if (Array.isArray(from)) {
        to := to || []
        to.length := from.length;
        var i = 0
        while (i < from.length) {
            to[i] := copy_to(from[i], to[i])
            i += 1
        }
    } else if (typeof(from) === "object") {
        to := (to || new {})
        Object.keys(from).forEach({ |k|
            to[k] := copy_to(from[k], to[k])
        })
    } else {
        to := from
    }

    return to
}

fn clone(obj) {
    return copy_to(obj, new {})
}

# TODO: Store world as flat array, except actions and player_states

pub fn world_reset(w) {
    w.frames := Array(FRAMES).fill(0).map({
        return new {
            switches: 0,
            actions: [],
            player_states: new {}
        }
    })
    w.observed_map.fill(0);
    w.reset_on := -1
    w.states := []
    w.offset := 0
    w.conflicts := 0
    w.current_state := 0
    w.current_player := 0
    w.current_player_state := new {
        aim: [1, 0],
        pos: [15.5, 15.5],
        cloak_timer: -1,
        inventory: []
    }
    w.visual := new Uint8Array(VISUAL_SIZE)

    w.states.push(clone(w.first_state))
    var time = 0
    for i in 1..STATES {
        let state = clone(w.states[w.states.length - 1])
        for j in 0..INTERVAL {
            state_update(state, w.frames[time], time)
            time += 1
        }
        w.states.push(state)
    }

    @debug console.log(w.states)
}

pub fn world_create() {
    let w = new {
        first_state: state_create(),
        observed_map: new Uint8Array(FRAMES*MAP_SIZE)
    }

    world_reset(w)

    return w
}

fn seen_wall(world, visual_wall_id) {
    let index = visual_wall_id + VISUAL_W*VISUAL_H + 2 * (VISUAL_W / 2) * (VISUAL_H / 2)
    let prev = world.visual[index]
    world.visual[index] := 1
    return prev
}

fn seen_cell(world, visual_cell_id) {
    let index = visual_cell_id + 2 * (VISUAL_W / 2) * (VISUAL_H / 2)
    let prev = world.visual[index]
    world.visual[index] := 1
    return prev
}

pub fn sweep5(world, s, originx, originy, dirx, diry, max_len, renders) {
    var iposx = originx | 0
    var iposy = originy | 0
    #var pipos = ipos
    var piposx = iposx, piposy = iposy
    var blocked = true
    var safe_counter = 0
    var length = 0
    #var composite_transform = [1, 0, 0, 1]
    var cur_wall
    var visual_wall_id = 0

    let div_start_x, div_start_y, north_south
    let s_visual = world.states[s].visual

    let inv_divx = 1 / dirx
    let inv_divy = 1 / diry

    loop {
        #[=
        safe_counter += 1
        if safe_counter > 100 {
            break
        }
        =]

        ray_steps += 1

        @debug if iposx < 0 || iposy < 0 || iposx >= W || iposy >= H {
            #@debug console.log("err")
            break
        }

        let visual_cell_id = visual_wall_id >> 1

        if renders && !seen_cell(world, visual_cell_id) {
            cell_render += 1

            let cur_cell = get_cell_(s_visual, iposx, iposy)
            let time = time_in_state(world, s)
            if cur_cell == CELL_PLAYER {
                
                Object.values(world.frames[time].player_states).forEach({ |p|
                    if iposx == (p.pos[0] | 0) &&
                       iposy == (p.pos[1] | 0) &&
                       p.cloak_timer < 0 {

                        # TODO: Check if we've rendered player id at visual_cell_id
                        renders.lines.push(new {
                            #from: vec.vsub2(p.pos, [originx, originy]),
                            fromx: p.pos[0] - originx,
                            fromy: p.pos[1] - originy,
                            #to: vec.vsub2(vec.vadd2(p.pos, p.aim), [originx, originy]),
                            tox: p.pos[0] + p.aim[0] - originx,
                            toy: p.pos[1] + p.aim[1] - originy,
                            color: 0xff0000ff
                            #trans: composite_transform
                        })
                    }
                })
            } else if is_key(cur_cell) {
                let p = [iposx + 0.5, iposy + 0.5]
                renders.lines.push(new {
                    fromx: iposx - originx,
                    fromy: iposy + 0.5 - originy,
                    tox: iposx + 1.0 - originx,
                    toy: iposy + 0.5 - originy,
                    #to: vec.vsub2([iposx + 1, iposy + 0.5], [originx, originy]),
                    color: 0xff00ffff
                    #trans: composite_transform
                })
            } else if cur_cell == CELL_EXIT {
                let p = [iposx + 0.5, iposy + 0.5]
                renders.lines.push(new {
                    fromx: iposx - originx,
                    fromy: iposy + 0.5 - originy,
                    tox: iposx + 1.0 - originx,
                    toy: iposy + 0.5 - originy,
                    color: 0xffffff00
                    #trans: composite_transform
                })
            } else if cur_cell == CELL_CLOAK {
                let p = [iposx + 0.5, iposy + 0.5]
                renders.lines.push(new {
                    fromx: iposx - originx,
                    fromy: iposy + 0.5 - originy,
                    tox: iposx + 1.0 - originx,
                    toy: iposy + 0.5 - originy,
                    color: 0xffaaaaaa
                    #trans: composite_transform
                })
            }
            
            # TODO: Check for conflict with map
            set_observed_cell(world, time, iposx, iposy, cur_cell)
        }


        #let dir_positive = [dirx, diry].map({|v| if v >= 0 { return 1 } else { return 0 }})
        let dir_positivex = if dirx >= 0 { 1 } else { 0 }
        let dir_positivey = if diry >= 0 { 1 } else { 0 }
        #let leap = vec.vadd2(vec.vsub2(ipos, [originx, originy]), dir_positive)
        let leapx = iposx - originx + dir_positivex
        let leapy = iposy - originy + dir_positivey
        #let length_we = leap[0] / dirx
        #let length_ns = leap[1] / diry
        let length_we = leapx * inv_divx #/ dirx TEMP Need to update inv
        let length_ns = leapy * inv_divy #/ diry
        north_south := length_ns < length_we

        #pipos := ipos
        piposx := iposx
        piposy := iposy

        #let div_start_x = ipos[0], div_start_y = ipos[1]
        
        if north_south {
            #ipos := vec.vadd2(ipos, [0, Math.sign(diry)])
            iposy += Math.sign(diry)
            visual_wall_id += Math.sign(diry) * (VISUAL_W * 2)
            div_start_x := iposx
            div_start_y := piposy + dir_positivey
            length := length_ns
        } else {
            #ipos := vec.vadd2(ipos, [Math.sign(dirx), 0])
            iposx += Math.sign(dirx)
            visual_wall_id += Math.sign(dirx) * 2
            div_start_x := piposx + dir_positivex
            div_start_y := iposy
            length := length_we
        }
        
        cur_wall := get_wall_(s_visual, div_start_x, div_start_y, north_south)

        if length >= max_len {
            length := max_len
            blocked := false
            break
        }


        if is_wall(cur_wall) {
            let angled_visual_wall_id = visual_wall_id + north_south
            let div_endx = div_start_x + north_south
            let div_endy = div_start_y + !north_south

            # Line is divider between pipos <-> ipos

            #if record && !set_wall(world.states[s].visual, div_start, north_south, 1) {
            if renders && !seen_wall(world, angled_visual_wall_id) {

                wall_render += 1

                # from/to can be used for sky vectors
                # trans * from/to is where to render
                let renderer = if cur_wall == WALL_WINDOW { renders.sky } else { renders.lines }

                let ax = div_start_x - originx
                let ay = div_start_y - originy
                let bx = div_endx - originx
                let by = div_endy - originy

                let swap = if north_south { dir_positivey } else { !dir_positivex }

                if swap {
                    let tempx = ax, tempy = ay
                    ax := bx
                    ay := by
                    bx := tempx
                    by := tempy
                }
                
                #let a = vec.vsub2([div_start_x, div_start_y], [originx, originy]),
                #    b = vec.vsub2([div_endx, div_endy], [originx, originy])
                renderer.push(new {
                    fromx: ax,
                    fromy: ay,
                    tox: bx,
                    toy: by,
                    color: if is_switch(cur_wall) { 0xffffff00 } else { 0xffffffff },
                    #trans: composite_transform,
                    s
                })

                let opt = world.states[s].options[cur_wall]
                if opt && opt["text"] {
                    # TODO: Apply this to all lines somehow
                    #let a = vec.vsub2([div_start_x, div_start_y], [originx, originy])
                    #let b = vec.vsub2([div_endx, div_endy], [originx, originy])
                    

                    renders.portal_texts.push(new {
                        fromx: ax,
                        fromy: ay,
                        tox: bx,
                        toy: by,
                        color: 0xffff0000,
                        text: opt["text"]
                        #trans: composite_transform
                    })
                }

                let time = time_in_state(world, s)

                # TODO: Check for conflict with map
                set_observed_wall(world, time, div_start_x, div_start_y, north_south, cur_wall)
            }

            break
        } else if is_teleport(cur_wall) {
            let angled_visual_wall_id = visual_wall_id + north_south
            let div_endx = div_start_x + north_south
            let div_endy = div_start_y + !north_south

            #if record && !set_wall(world.states[s].visual, div_start, north_south, 1) {
            let opt = world.states[s].options[cur_wall & ~1]
            let sign = if cur_wall & 1 { -1 } else { 1 }

            # TODO: option to block portal based on (north_south ? dir_positivex : dir_positivey)

            let pos_diffx = sign * opt["pos_diff"][0],
                pos_diffy = sign * opt["pos_diff"][1]
            let state_diff = sign * opt["state_diff"]
            # TODO: Check if (time + state_diff * INTERVAL) is outside
            # time. If so, render wall and break

            if renders && !seen_wall(world, angled_visual_wall_id) {

                #let a = vec.vsub2([div_start_x, div_start_y], [originx, originy])
                let ax = div_start_x - originx
                let ay = div_start_y - originy
                #let b = vec.vsub2([div_endx, div_endy], [originx, originy])
                let bx = div_endx - originx
                let by = div_endy - originy

                renders.lines.push(new {
                    #from: vec.vsub2([div_start_x, div_start_y], [originx, originy]),
                    fromx: ax,
                    fromy: ay,
                    #to: vec.vsub2([div_endx, div_endy], [originx, originy]),
                    tox: bx,
                    toy: by,
                    color: 0xffff0000
                    #trans: composite_transform
                })

                # TODO: Apply this to all lines somehow
                let swap = if north_south { dir_positivey } else { !dir_positivex }
                
                if swap {
                    let tempx = ax, tempy = ay
                    ax := bx
                    ay := by
                    bx := tempx
                    by := tempy
                }

                renders.portal_texts.push(new {
                    fromx: ax,
                    fromy: ay,
                    tox: bx,
                    toy: by,
                    color: 0xffff0000
                    #trans: composite_transform
                })
            }

            #ipos := vec.vsub2(vec.vadd2(ipos, pos_diff), dir_positive)
            iposx := iposx + pos_diffx - dir_positivex
            iposy := iposy + pos_diffy - dir_positivey
            originx += pos_diffx
            originy += pos_diffy
            let linedx = dirx * length
            let linedy = diry * length
            # [originx, originy] := vec.vsub2(vec.vadd2([originx, originy], lined), lined) # TODO: Mult with trans
            originx -= originx + linedx
            originy -= originy + linedy
            # TODO: [dirx, diry] = trans * [dirx, diry];
            # TODO: change inv* too

            #ipos := vec.vadd2(ipos, [dirx, diry].map({|v| if v >= 0.0 { return 1 } else { return 0 }}))
            iposx := iposx + if dirx >= 0 { 1 } else { 0 }
            iposy := iposy + if diry >= 0 { 1 } else { 0 }
            s := (s + STATES + state_diff) % STATES
            s_visual := world.states[s].visual
        }

        #[=
        let cur_cell = get_cell(world.states[s].map, ipos)
        let prev_visual = set_cell(world.states[s].visual, ipos, 1)
        
        if record {
            if !prev_visual && is_wall(cur_cell) {
                #console.log(ipos, vec.vsub2(ipos, [originx, originy]))
                renders.push(new {
                    ul: vec.vsub2(ipos, [originx, originy]),
                    trans: composite_transform
                })
                let time = time_in_state(world, s)
                set_cell(world.frames[time].observed_map, ipos, cur_cell)
            }
        }

        =]
#[=
        if is_wall(cur_cell) {
            break
        }
=]
    }

    return new {
        origin: [originx, originy],
        blocked,
        end_s: s,
        end_pos: vec.vadd2([originx, originy], vec.vmul2([dirx, diry], length)),
        end_ipos: [iposx, iposy],
        end_div_start: [div_start_x, div_start_y],
        end_ns: north_south,
        end_wall: cur_wall,
        end_length: length
        #trans: composite_transform
    }
}

fn sweep(world, origin, aim, renders) {
    world.visual.fill(0)

    let fov = 1
    let fov_vec = [Math.cos(fov / 2), Math.sin(fov / 2)]

    let a = vec.vrotate(aim, [fov_vec[0], -fov_vec[1]])
    let b = vec.vsub2(vec.vrotate(aim, fov_vec), a)
    var i = 0
    let rays = 512
    #let rays = 100
    while i < rays {
        let m = vec.vadd2(a, vec.vmul2(b, (i / rays)))
        m := vec.vmul2(m, 1 / Math.hypot(m[0], m[1]))
        sweep5(world, world.current_state, origin[0], origin[1], m[0], m[1], 64, renders)
        i += 1
    }
}

pub fn current_player_time(world) {
    return time_in_state(world, world.current_state)
}

pub fn world_update(world, action, renders, paused) {

    if !paused {
        for s in 0..STATES {
            let time = time_in_state(world, s)
            state_update(world.states[s], world.frames[time], time)
            if time == FRAMES - 1 {
                if world.current_state == s {
                    # We're here, we'll die :(
                    world.current_player += 1 # For now, just "rebirth" as new player
                }
                world.states[s] := clone(world.first_state)
            }
        }
    }

    var switch_ons = 0

    world.current_player_state.aim := action.aim;
    if action.act {
        let act_result = sweep5(world, world.current_state,
            world.current_player_state.pos[0]
            world.current_player_state.pos[1],
            action.aim[0],
            action.aim[1],
            1)
        if act_result.blocked {
            if is_switch(act_result.end_wall) {
                let opt = world.states[world.current_state].options[act_result.end_wall]
                let ok = false
                if opt && opt.required_key {
                    if world.current_player_state.inventory[opt.required_key] {
                        world.current_player_state.inventory[opt.required_key] -= 1
                        ok := true
                    }
                }

                if ok {
                    #@debug console.log("activated", act_result.end_div_start, act_result.end_ns)
                    let switch_id = act_result.end_wall - WALL_SWITCH0
                    #world.states[world.current_state].switches |= 1 << switch_id
                    switch_ons |= 1 << switch_id
                    @debug console.log("switched")
                } else {
                    # TODO: Play denied sound
                    @debug console.log("denied")
                }
            }
        } else {
            #@debug console.log("found nothing")
        }
    }

    if action.walk[0] || action.walk[1] {
        let pi = world.current_player_state.pos
        let walk_dir = vec.vnormalize2(action.walk)

        let result = sweep5(world, world.current_state,
            world.current_player_state.pos[0],
            world.current_player_state.pos[1],
            walk_dir[0],
            walk_dir[1],
            WALK_SPEED)

        if !result.blocked {
            let time = current_player_time(world)
            if time_in_state(world, result.end_s) < time {
                @debug console.log("going back to", time_in_state(world, result.end_s))
                world.current_player += 1
            }
            # TEMP!
            if time_in_state(world, result.end_s) != time {
                world.current_player += 1
            }
            world.current_state := result.end_s
            world.current_player_state.pos := result.end_pos;

            # TODO: 
            #world.current_player_state.aim = result.trans.transpose() * self.current_player_state.aim;
        }

        var ang = 0, min_dist = 10, min_dir
        while ang < Math.PI*2 {
            let dir = [Math.cos(ang), Math.sin(ang)]
            let res = sweep5(world, world.current_state,
                world.current_player_state.pos[0],
                world.current_player_state.pos[1],
                dir[0],
                dir[1],
                PLAYER_RADIUS)
            if res.blocked && res.end_length < min_dist {
                min_dist := res.end_length
                min_dir := dir
            }
            ang += 0.2
        }

        if min_dir {
            world.current_player_state.pos := vec.vsub2(
                world.current_player_state.pos,
                vec.vmul2(min_dir, (PLAYER_RADIUS - min_dist)))
        }

        # TODO: If standing on e.g. a cloak crystal, reset cloak timer
        # Pick up items and insert
        let at = loc_from_coords(world.current_player_state.pos)
        let on_cell = get_loc(world.states[world.current_state].map, at)
        if on_cell == CELL_EXIT {
            if world.reset_on < 0 {
                world.reset_on := world.offset + RESET_TIMER
                # TODO: Increment level
            }
        } else if on_cell == CELL_CLOAK {
            world.current_player_state.cloak_timer := CLOAK_TIME
        } else if is_pickable(on_cell) {
            let time = current_player_time(world);
            world.current_player_state.inventory[on_cell] |= 1
            let to = CELL_FLOOR
            set_loc(world.states[world.current_state].map, at, to)
            world.frames[time].actions.push([ ACTION_CHANGE, at, to ])

            @debug console.log("current inventory:", world.current_player_state.inventory)
        }
    }

    world.current_player_state.cloak_timer -= 1

    if !paused {
        world.offset += 1
    }

    let now = current_player_time(world)
    world.frames[now].player_states[world.current_player] :=
        clone(world.current_player_state)
    # Record switch activations by current player
    world.frames[now].switches |= switch_ons

    let origin = world.current_player_state.pos
    let aim = world.current_player_state.aim
    for s in 0..STATES {
        let time = time_in_state(world, s)
        # Set visual map
        state_preprocess(world.states[s], world.frames[time], time)
    }
    let prev_conflicts = world.conflicts
    sweep(world, origin, aim, renders)
    if world.conflicts != prev_conflicts && !paused {
        # Violation
        if get_observed_cell(world, now, world.current_player_state.pos[0] | 0, world.current_player_state.pos[1] | 0) != CELL_PLAYER {
            # TODO: Try past locations first
            for i in 0..20 {
                world.current_player_state.pos := [Math.random() * 31, Math.random() * 31]
                let dest = get_observed_cell(world, now, world.current_player_state.pos[0], world.current_player_state.pos[1])
                if dest == 0 || dest == CELL_PLAYER {
                    break
                }
            }
            # Write new player state
            world.frames[now].player_states[world.current_player] :=
                clone(world.current_player_state)
        } else {
            # Violation is likely that we saw something we shouldn't
            # One way to fix is to blind the player
        }
    }

    if world.offset == world.reset_on {
        world_reset(world)
    }

    if !paused && (now % SECOND) == 0 {
        let seconds = (now / SECOND)
        @debug console.log((seconds / 60) | 0, seconds % 60, "player ", world.current_player)
        @debug console.log("renders:", wall_render, cell_render, ray_steps)
        wall_render := 0
        cell_render := 0
        ray_steps := 0
    }
}
