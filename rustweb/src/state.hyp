use vecmath as vec

pub let W = 32, H = 32
pub let MAP_SECTION_SIZE = W*H;
pub let MAP_SIZE = MAP_SECTION_SIZE*3
pub let SECOND = 60
pub let MINUTE = 60 * SECOND
pub let TIME_IN_MINUTES = 1
pub let TIME_IN_SECONDS = TIME_IN_MINUTES * 60
pub let INTERVAL = 10 * SECOND
pub let FRAMES = TIME_IN_MINUTES * MINUTE
pub let STATES = FRAMES / INTERVAL
pub let VISUAL_W = 512, VISUAL_H = 512
pub let VISUAL_SIZE = VISUAL_W * VISUAL_H * 3

@debug console.log("INTERVAL", INTERVAL)
@debug console.log("STATES", STATES)
@debug console.log("FRAMES", FRAMES)

pub let CELL_FLOOR = 1,
    CELL_BLOCK = 2,
    CELL_TELEPORT0 = 4,
    CELL_TELEPORT_MAX = CELL_TELEPORT0 + 5*2,
    CELL_SWITCH0 = CELL_TELEPORT_MAX,
    CELL_SWITCH_MAX = CELL_SWITCH0 + 10,
    CELL_DOOR0 = CELL_SWITCH_MAX,
    CELL_DOOR_MAX = CELL_DOOR0 + 10,
    CELL_WINDOW = CELL_DOOR_MAX,
    CELL_CONFLICT = 255


pub let ACTION_CHANGE = 0,
    ACTION_MOVE = 1

pub fn is_switch(cell) {
    return cell >= CELL_SWITCH0 && cell < CELL_SWITCH_MAX
}

pub fn is_door(cell) {
    return cell >= CELL_DOOR0 && cell < CELL_DOOR_MAX
}

pub fn is_wall(cell) {
    return cell == CELL_BLOCK || is_switch(cell) || cell == CELL_WINDOW
}

pub fn is_teleport(cell) {
    return cell >= CELL_TELEPORT0 && cell < CELL_TELEPORT_MAX # TODO
}

fn map_create() {
    return Array(MAP_SIZE).fill(0)
}

fn set_cell(map, [x, y], what) {
    let prev = map[y*W + x]
    map[y*W + x] := what
    return prev
}

pub fn set_wall(map, [x, y], wall_dir, what) {
    let prev = map[y*W + x + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
    map[y*W + x + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
    return prev
}

pub fn set_wall_(map, x, y, wall_dir, what) {
    let prev = map[y*W + x + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
    map[y*W + x + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
    return prev
}

pub fn set_cell_(map, x, y, what) {
    let prev = map[y*W + x]
    map[y*W + x] := what
    return prev
}

pub fn set_observed_wall(world, time, x, y, wall_dir, what) {
    let index = time*MAP_SIZE + y*W + x + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir
    let prev = world.observed_map[index]
    if what == 0 {
        return prev
    } else if prev && prev != what {
        if prev != CELL_CONFLICT {
            world.conflicts += 1
            world.observed_map[index] := CELL_CONFLICT
            #@debug console.log(prev, what)
        }
    } else {
        world.observed_map[index] := what
    }
    return prev
}

pub fn get_observed_wall(world, time, x, y, wall_dir) {
    let index = time*MAP_SIZE + y*W + x + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir
    return world.observed_map[index]
}

pub fn set_observed_cell(world, time, x, y, what) {
    let index = time*MAP_SIZE + y*W + x
    let prev = world.observed_map[index]
    if what == 0 {
        return prev
    } else if prev && prev != what {
        if prev != CELL_CONFLICT {
            world.conflicts += 1
            world.observed_map[index] := CELL_CONFLICT
            #@debug console.log(prev, what, x, y)
        }
    } else {
        world.observed_map[index] := what
    }
    return prev
}

pub fn get_observed_cell(world, time, x, y) {
    let index = time*MAP_SIZE + y*W + x
    return world.observed_map[index]
}

pub fn get_cell(map, [x, y]) {
    return map[y*W + x]
}

pub fn get_cell_(map, x, y) {
    return map[y*W + x]
}

pub fn get_wall(map, [x, y], wall_dir) {
    return map[y*W + x + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
}

pub fn get_wall_(map, x, y, wall_dir) {
    return map[y*W + x + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir]
}

fn set_loc(map, loc, what) {
    map[loc] := what
}

fn set_wall_loc(map, loc, wall_dir, what) {
    map[loc + MAP_SECTION_SIZE + MAP_SECTION_SIZE*wall_dir] := what
}

pub fn state_create() {
    let self = new {
        map: map_create(),
        visual: map_create(),
        options: new {},
        prev_switches: 0,
        switches: 0,
        prev_outputs: 0,
        outputs: 0,
    }

    self.options[CELL_TELEPORT0] := new {}
    self.options[CELL_TELEPORT0]["pos_diff"] := [-31, 0]
    self.options[CELL_TELEPORT0]["state_diff"] := -1

    for y in 0..H {
        for x in 0..W {
            set_wall(self.map, [x, y], false, CELL_FLOOR)
            set_wall(self.map, [x, y], true, CELL_FLOOR)

            if x == 0 || x == W - 1 || y == 0 || y == H - 1 {
                if y == 0 || y == H - 1 {
                    set_wall(self.map, [x, y], true, CELL_BLOCK)
                }
                if x == 0 || x == W - 1 {
                    set_wall(self.map, [x, y], false, CELL_BLOCK)
                }
            }
            set_cell(self.map, [x, y], CELL_FLOOR)
        }
    }

    #console.log(get_wall(self.map, [31, 15], false))
    #set_wall(self.map, [31, 9], false, CELL_TELEPORT0)
    #set_wall(self.map, [31, 10], false, CELL_TELEPORT0)
    
#[=
    self.map[511] := CELL_BLOCK
    self.map[512] := CELL_BLOCK
    set_cell(self.map, [18, 16], CELL_BLOCK)
    set_cell(self.map, [30, 18], CELL_BLOCK)
    # 31, 18 not visible
=]

    @debug console.log(self.map)

    return self
}

pub fn state_preprocess(state, frame, time) {
    for i in 0..MAP_SIZE {
        # Modify based on state
        let cell = state.map[i]
        if is_teleport(cell) {
            let opt = state.options[cell & ~1]
            let sign = if cell & 1 { -1 } else { 1 }
            let state_diff = sign * opt["state_diff"]
            let new_time = time + state_diff * INTERVAL

            if new_time >= FRAMES || new_time < 0 {
                cell := CELL_BLOCK
            }
        } else if is_door(cell) {
            let door_id = cell - CELL_DOOR0
            if !(state.outputs & (1 << door_id)) {
                cell := CELL_BLOCK
            }
        }

        state.visual[i] := cell
    }

    Object.values(frame.player_states).forEach({ |s|
        # TODO: Set flag on all covered cells
        set_cell_(state.visual, s.pos[0] | 0, s.pos[1] | 0, 2)
    })
}

pub fn state_update(state, frame, time) {
    let current = frame.switches
    let change_on = ~state.prev_switches & current
    let any_change = state.prev_switches != current
    state.prev_switches := current

    if any_change {
        @debug console.log("switches:", current)
    }

    #state.switches |= frame.switches

    state.prev_outputs := state.outputs
    #state.outputs := state.outputs ^ change
    state.outputs := current & (current >> 1)

    if state.prev_outputs != state.outputs {
        @debug console.log("outputs changed:", state.outputs)
    }

    

    frame.actions.forEach({ |[ty, a, b, c]|
        if (ty == ACTION_CHANGE) {
            set_loc(state.map, a, b)
        } else if (ty == ACTION_MOVE) {

        }
    })
}

fn time_in_state(world, s) {
    return (world.offset + s * INTERVAL) % FRAMES
}

fn copy_to(from, to) {
    if (Array.isArray(from)) {
        to := to || []
        to.length := from.length;
        var i = 0
        while (i < from.length) {
            to[i] := copy_to(from[i], to[i])
            i += 1
        }
    } else if (typeof(from) === "object") {
        to := (to || new {})
        Object.keys(from).forEach({ |k|
            to[k] := copy_to(from[k], to[k])
        })
    } else {
        to := from
    }

    return to
}

fn clone(obj) {
    return copy_to(obj, new {})
}

# TODO: Store world as flat array, except actions and player_states

pub fn world_reset(w) {
    w.frames := Array(FRAMES).fill(0).map({
        return new {
            switches: 0,
            actions: [],
            player_states: new {}
        }
    })
    w.observed_map.fill(0);
    w.states := []
    w.offset := 0
    w.conflicts := 0
    w.current_state := 0
    w.current_player := 0
    w.current_player_state := new {
        aim: [1, 0],
        pos: [15.5, 15.5],
        inventory: []
    }
    w.visual := new Uint8Array(VISUAL_SIZE)

    w.states.push(clone(w.first_state))
    var time = 0
    for i in 1..STATES {
        let state = clone(w.states[w.states.length - 1])
        for j in 0..INTERVAL {
            state_update(state, w.frames[time], time)
            time += 1
        }
        w.states.push(state)
    }

    @debug console.log(w.states)
}

pub fn world_create() {
    let w = new {
        first_state: state_create(),
        observed_map: new Uint8Array(FRAMES*MAP_SIZE)
    }

    world_reset(w)

    return w
}

fn seen_wall(world, visual_wall_id) {
    let index = visual_wall_id + VISUAL_W*VISUAL_H + 2 * (VISUAL_W / 2) * (VISUAL_H / 2)
    let prev = world.visual[index]
    world.visual[index] := 1
    return prev
}

fn seen_cell(world, visual_cell_id) {
    let index = visual_cell_id + 2 * (VISUAL_W / 2) * (VISUAL_H / 2)
    let prev = world.visual[index]
    world.visual[index] := 1
    return prev
}

pub fn sweep5(world, s, origin, dir, max_len, renders) {
    var iposx = origin[0] | 0
    var iposy = origin[1] | 0
    #var pipos = ipos
    var piposx = iposx, piposy = iposy
    var blocked = true
    var safe_counter = 0
    var length = 0
    var composite_transform = [1, 0, 0, 1]
    var cur_wall
    var visual_wall_id = 0

    let div_start_x, div_start_y, north_south

    loop {
        safe_counter += 1
        if safe_counter > 100 {
            break
        }

        let visual_cell_id = visual_wall_id / 2

        if iposx < 0 || iposy < 0 || iposx >= W || iposy >= H {
            @debug console.log("err")
            break
        }

        if renders && !seen_cell(world, visual_cell_id) {
            let cur_cell = get_cell_(world.states[s].visual, iposx, iposy)
            let time = time_in_state(world, s)
            if cur_cell >= 2 {
                
                Object.values(world.frames[time].player_states).forEach({ |p|
                    if iposx == (p.pos[0] | 0) && iposy == (p.pos[1] | 0) {
                        # TODO: Check if we've rendered player id at visual_cell_id
                        renders.lines.push(new {
                            from: vec.vsub2(p.pos, origin),
                            to: vec.vsub2(vec.vadd2(p.pos, p.aim), origin),
                            color: 0xff0000ff,
                            trans: composite_transform
                        })
                    }
                })
            }
            
            # TODO: Check for conflict with map
            set_observed_cell(world, time, iposx, iposy, cur_cell)
        }


        #let dir_positive = dir.map({|v| if v >= 0 { return 1 } else { return 0 }})
        let dir_positivex = if dir[0] >= 0 { 1 } else { 0 }
        let dir_positivey = if dir[1] >= 0 { 1 } else { 0 }
        #let leap = vec.vadd2(vec.vsub2(ipos, origin), dir_positive)
        let leapx = iposx - origin[0] + dir_positivex
        let leapy = iposy - origin[1] + dir_positivey
        #let length_we = leap[0] / dir[0]
        #let length_ns = leap[1] / dir[1]
        let length_we = leapx / dir[0]
        let length_ns = leapy / dir[1]
        north_south := length_ns < length_we

        #pipos := ipos
        piposx := iposx
        piposy := iposy

        #let div_start_x = ipos[0], div_start_y = ipos[1]
        div_start_x := iposx
        div_start_y := iposy

        if north_south {
            #ipos := vec.vadd2(ipos, [0, Math.sign(dir[1])])
            iposy += Math.sign(dir[1])
            visual_wall_id += Math.sign(dir[1]) * (VISUAL_W * 2)
            #div_start_y := Math.max(pipos[1], ipos[1])
            div_start_y := Math.max(piposy, iposy)
            length := length_ns
        } else {
            #ipos := vec.vadd2(ipos, [Math.sign(dir[0]), 0])
            iposx += Math.sign(dir[0])
            visual_wall_id += Math.sign(dir[0]) * 2
            #div_start_x := Math.max(pipos[0], ipos[0])
            div_start_x := Math.max(piposx, iposx)
            length := length_we
        }

        #let div_start = [div_start_x, div_start_y]
        #let div_end = [div_start[0] + north_south, div_start[1] + !north_south]
        let div_endx = div_start_x + north_south
        let div_endy = div_start_y + !north_south

        # TODO: Compute map based on states
        cur_wall := get_wall_(world.states[s].visual, div_start_x, div_start_y, north_south)

        if length >= max_len {
            length := max_len
            blocked := false
            break
        }

        let angled_visual_wall_id = visual_wall_id + north_south

        if is_wall(cur_wall) {
            # Line is divider between pipos <-> ipos

            #if record && !set_wall(world.states[s].visual, div_start, north_south, 1) {
            if renders && !seen_wall(world, angled_visual_wall_id) {

                # TODO: Split into different piles based on which
                # shader they need and whether they need to be sorted.
                # from/to can be used for sky vectors
                # trans * from/to is where to render
                let renderer = if cur_wall == CELL_WINDOW { renders.sky } else { renders.lines }

                renderer.push(new {
                    from: vec.vsub2([div_start_x, div_start_y], origin),
                    to: vec.vsub2([div_endx, div_endy], origin),
                    color: if is_switch(cur_wall) { 0xffffff00 } else { 0xffffffff },
                    trans: composite_transform
                })

                let time = time_in_state(world, s)

                # TODO: Check for conflict with map
                set_observed_wall(world, time, div_start_x, div_start_y, north_south, cur_wall)
            }

            break
        } else if is_teleport(cur_wall) {
            #if record && !set_wall(world.states[s].visual, div_start, north_south, 1) {
            let opt = world.states[s].options[cur_wall & ~1]
            let sign = if cur_wall & 1 { -1 } else { 1 }

            let pos_diff = [sign * opt["pos_diff"][0], sign * opt["pos_diff"][1]]
            let state_diff = sign * opt["state_diff"]
            # TODO: Check if (time + state_diff * INTERVAL) is outside
            # time. If so, render wall and break

            if renders && !seen_wall(world, angled_visual_wall_id) {

                renders.lines.push(new {
                    from: vec.vsub2([div_start_x, div_start_y], origin),
                    to: vec.vsub2([div_endx, div_endy], origin),
                    color: 0xffff0000,
                    trans: composite_transform
                })

                # TODO: Apply this to all lines somehow
                let swap = if north_south { dir[1] > 0 } else { dir[0] < 0 }
                let a = vec.vsub2([div_start_x, div_start_y], origin)
                let b = vec.vsub2([div_endx, div_endy], origin)

                if swap {
                    let temp = a
                    a := b
                    b := temp
                }

                renders.portal_texts.push(new {
                    from: a,
                    to: b,
                    color: 0xffff0000,
                    trans: composite_transform
                })
            }

            #ipos := vec.vsub2(vec.vadd2(ipos, pos_diff), dir_positive)
            iposx := iposx + pos_diff[0] - dir_positivex
            iposy := iposy + pos_diff[1] - dir_positivey
            origin := vec.vadd2(origin, pos_diff)
            let lined = vec.vmul2(dir, length)
            origin := vec.vsub2(vec.vadd2(origin, lined), lined) # TODO: Mult with trans
            # TODO: dir = trans * dir;

            #ipos := vec.vadd2(ipos, dir.map({|v| if v >= 0.0 { return 1 } else { return 0 }}))
            iposx := iposx + if dir[0] >= 0 { 1 } else { 0 }
            iposy := iposy + if dir[1] >= 0 { 1 } else { 0 }
            s := (s + STATES + state_diff) % STATES
        }

        #[=
        let cur_cell = get_cell(world.states[s].map, ipos)
        let prev_visual = set_cell(world.states[s].visual, ipos, 1)
        
        if record {
            if !prev_visual && is_wall(cur_cell) {
                #console.log(ipos, vec.vsub2(ipos, origin))
                renders.push(new {
                    ul: vec.vsub2(ipos, origin),
                    trans: composite_transform
                })
                let time = time_in_state(world, s)
                set_cell(world.frames[time].observed_map, ipos, cur_cell)
            }
        }

        =]
#[=
        if is_wall(cur_cell) {
            break
        }
=]
    }

    return new {
        origin,
        blocked,
        end_s: s,
        end_pos: vec.vadd2(origin, vec.vmul2(dir, length)),
        end_ipos: [iposx, iposy],
        end_div_start: [div_start_x, div_start_y],
        end_ns: north_south,
        end_wall: cur_wall,
        trans: composite_transform
    }
}

fn sweep(world, origin, aim, renders) {
    #world.states.forEach({|s| 
    #    s.visual.fill(0)
    #})
    world.visual.fill(0)

    let fov = 1
    let fov_vec = [Math.cos(fov / 2), Math.sin(fov / 2)]

    let a = vec.vrotate(aim, [fov_vec[0], -fov_vec[1]])
    let b = vec.vsub2(vec.vrotate(aim, fov_vec), a)
    var i = 0
    let rays = 512
    #let rays = 100
    while i < rays {
        let m = vec.vadd2(a, vec.vmul2(b, (i / rays)))
        m := vec.vmul2(m, 1 / Math.hypot(m[0], m[1]))
        sweep5(world, world.current_state, origin, m, 64, renders)
        i += 1
    }
}

pub fn current_player_time(world) {
    return time_in_state(world, world.current_state)
}

pub fn world_update(world, action, renders, paused) {

    if !paused {
        for s in 0..STATES {
            let time = time_in_state(world, s)
            state_update(world.states[s], world.frames[time], time)
            if time == FRAMES - 1 {
                if world.current_state == s {
                    # We're here, we'll die :(
                    world.current_player += 1 # For now, just "rebirth" as new player
                }
                world.states[s] := clone(world.first_state)
            }
        }
    }

    var switch_ons = 0

    world.current_player_state.aim := action.aim;
    if action.act {
        let act_result = sweep5(world, world.current_state,
            world.current_player_state.pos,
            action.aim,
            1)
        if act_result.blocked {
            if is_switch(act_result.end_wall) {
                #@debug console.log("activated", act_result.end_div_start, act_result.end_ns)
                let switch_id = act_result.end_wall - CELL_SWITCH0
                #world.states[world.current_state].switches |= 1 << switch_id
                switch_ons |= 1 << switch_id

                let time = time_in_state(world, s)
                # TODO: I think this should be added to the next frame
                #world.frames[time].switches |= 1 << switch_id
            }
        } else {
            #@debug console.log("found nothing")
        }
    }

    if action.walk[0] || action.walk[1] {
        let pi = world.current_player_state.pos
        let walk_dir = vec.vnormalize2(action.walk)

        
        # TODO: Use a longer ray to detect which wall you're facing when activating
        # wall switches etc.
        let result = sweep5(world, world.current_state,
            world.current_player_state.pos,
            walk_dir,
            0.1)

        if !result.blocked {
            let time = current_player_time(world)
            if time_in_state(world, result.end_s) < time {
                @debug console.log("going back to", time_in_state(world, result.end_s))
                #world.current_player += 1 TEMP
            }
            if time_in_state(world, result.end_s) != time { # TEMP!
                world.current_player += 1
            }
            world.current_state := result.end_s
            world.current_player_state.pos := result.end_pos;

            # TODO: 
            #world.current_player_state.aim = result.trans.transpose() * self.current_player_state.aim;

            #[=
            let target_cell = get_cell(world.states[world.current_state].map, result.end_ipos);
            if is_pickable(target_cell) {
                let time = world.current_player_time();
                world.current_player_state.inventory[target_cell] += 1;
                let at = result.end_ipos[0]|(result.end_ipos[1] << 5);
                let to = CELL_FLOOR;

                world.frames[time].actions.push([ ACTION_CHANGE, at, to ]);
                set_loc(world.states[world.current_state].map, at, to);
            }
            =]
        }
    }

    if !paused {
        world.offset += 1
    }

    let now = current_player_time(world)
    world.frames[now].player_states[world.current_player] :=
        clone(world.current_player_state)
    # Record switch activations by current player
    world.frames[now].switches |= switch_ons

    let origin = world.current_player_state.pos
    let aim = world.current_player_state.aim
    for s in 0..STATES {
        let time = time_in_state(world, s)
        # Set visual map
        state_preprocess(world.states[s], world.frames[time], time)
    }
    sweep(world, origin, aim, renders)

    if !paused && (now % SECOND) == 0 {
        let seconds = (now / SECOND)
        @debug console.log((seconds / 60) | 0, seconds % 60, "player ", world.current_player)
    }
}
