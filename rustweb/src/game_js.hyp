use "glsl/main" as main_glsl
use render
use state
use vecmath as vec
use editor

#let uniLocs
#let uniNames = ["t", "P", "R"]

let fs = main_glsl.main
#let wasm_U8 = new Uint8Array(wasm.memory.buffer)

#console.log(wasm.RENDER_BUF)

fn genTex(pixels, ty, f) {
    let side = Math.sqrt(pixels.length)
    let w = side
    let h = side
    var i = 0, y = 0

    while y < h {
        var x = 0
        while x < w {
            pixels[i] := f(x, y)
            x += 1
            i += 1
        }
        y += 1
    }

    let pixtex = render.createTexture(pixels, side, ty)

    @debug console.log(pixels)

    pixtex.d := pixels
    return pixtex
}

fn clamp(x, min, max) {
    if x <= min {
        return min
    } else if x >= max {
        return max
    } else {
        return x
    }
}

# TODO: Put in binary section
let fontBits = atob("1tb7v+b97tm0mua3bd+RTdi2aZKKzd+2UduWlfRd/5f+v7j8XS+1l1SFZFO2adKqTd98VPUq08c9X+c97tW3ijtZrQ4=").
    split("").
    map({ |x| return x.charCodeAt(0) })
var whiteTex

fn startGame() {
    let gl, imgShader, translucentShader,
        skyShader
    let canvas = document.getElementById("g")
    #let canvas = document.getElementsByTagName("canvas")[0]
    
    render.init(canvas)
    gl := render.gl

    skyShader :=render.createShaderProgram(render.basicVs, main_glsl.sky)
    imgShader := render.createShaderProgram(render.basicVs, fs)
    translucentShader := render.createShaderProgram(render.basicVs, main_glsl.translucent)
    
    #uniLocs := uniNames.map(|name| { return gl.getUniformLocation(imgShader, name) })

    fn getPointColor(x, y) {
        let alpha = ((7.5 - Math.hypot(x - 8, y - 8)) * 64.0) | 0
        #return 0x00ffffff + (clamp(alpha, 0, 255) << 24)
        return 0x001010ff + (clamp(alpha, 0, 255) << 24)
    }


    let pointTex = genTex(new Uint32Array(16*16), render.GL_RGBA, getPointColor)
    whiteTex := genTex(new Uint32Array(1), render.GL_RGBA, { return 0xffffffff });
    let world = state.world_create()

    let keys = new {}, audio
    let aim = [1, 0]
    window.onkeydown := { |ev|
        keys[ev.keyCode] := 1
    }

    window.onkeyup := { |ev|
        keys[ev.keyCode] := 0
    }

    fn play2(buf) {
        if (audio) {
            var src = audio.createBufferSource()
            var pan = audio.createStereoPanner()
            var gain = audio.createGain()
            gain.gain.value := 0.5
            pan.pan.value := 0.8

            src.buffer := buf
            #src.playbackRate.value = 1.2;
            src.connect(gain).connect(pan).connect(audio.destination)
            src.start()
        }
    }

    canvas.onclick := {
        if (!audio) {
            audio := new AudioContext()
            var bufSize = 16384
            let scriptProc = audio.createScriptProcessor(bufSize, 0, 1)
            let time = 0
            let tick = 0
            let start = 44100 * 2
            let beep = Array(44100 >> 2).fill(0).map({ |s, x| return 0.2 * Math.sin(220 * 2 * Math.PI * x / 44100) })

            let samples = []

            fn play1() {
                samples.push([tick, beep])
            }

            @debug console.log(beep)

            let t = 0
            scriptProc.onaudioprocess := { |e|
                let left = e.outputBuffer.getChannelData(0)

                for i in 0..bufSize {
                    left[i] := "%,IW7:A".charCodeAt(i%7) * t % 0.1*(1-t/(Math.tan(i%7)+9)%1)
                    t += 0.00002
                }

                #[=
                samples = samples.filter(([start, sample]) => {
                    var pan = 1;
                    for (var i = 0; i < sample.length; ++i) {
                        left[start + i - tick] += sample[i] * (1 - Math.max(pan, 0));
                        right[start + i - tick] += sample[i] * (1 + Math.min(pan, 0));
                    }
                    return tick + bufSize - sample.length < start;
                });
                =]
                
                tick += bufSize
            }
            # TODO
            #scriptProc.connect(audio.destination)

            let buf = audio.createBuffer(1, beep.length, 44100)
            buf.getChannelData(0).set(beep)

            #play1();
            play2(buf);
        }
        canvas.requestPointerLock()
    }

    canvas.onmousemove := { |e|
        if (document.pointerLockElement == canvas) {
            let xdiff = e.movementX / 500
            aim := vec.vrotate(aim, [Math.cos(xdiff), Math.sin(xdiff)])
        }
    }

    # editor state
    # up down left right
    # 85, 69, 65, 79
    editor.start(world)
    
    fn update() {
        window.requestAnimationFrame({ |currentTime|
            update()
            let walkSpeed = 0.1;
            var walk = [0, 0]
            if (keys[71]) {
                walk := vec.vadd2(walk, vec.vmul2(aim, walkSpeed))
            } else if (keys[83]) {
                walk := vec.vsub2(walk, vec.vmul2(aim, walkSpeed))
            }

            if (keys[68]) {
                walk := vec.vadd2(walk, vec.vmul2([aim[1], -aim[0]], walkSpeed))
            } else if (keys[84]) {
                walk := vec.vsub2(walk, vec.vmul2([aim[1], -aim[0]], walkSpeed))
            }
            
            let renders = [], line_renders = [], sky_line_renders = []
            state.world_update(world, new {
                aim,
                walk,
                act: keys[81]
            }, renders, line_renders, sky_line_renders, editor.paused)

            #console.log("rendering,", renders.length, "boxes")
            render.canvas_w := canvas.width := window.innerWidth
            render.canvas_h := canvas.height := window.innerHeight
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)
            gl.clear(render.GL_COLOR_BUFFER_BIT)
            #render.setView(0, 0, Math.cos(rot), Math.sin(rot), 1.0)
            #rot += 0.01
            render.color(0xffffffff)
            render.setView2(aim)
            render.activateShader(translucentShader)
            #render.activateShader(skyShader)
            #[=
            let z = -2500
            render.wall3d(pointTex, -1000, z, 1000, z, -1024, 1024,
                0, 0, 1, 1)
            =]

            renders.forEach({ |r|
                let step = 100 #512 * 2
                let z = (-r.ul[0] - 1) * step
                let x = r.ul[1] * step
                render.wall3d(pointTex, x + step, z, x, z, -step / 2, step / 2, 0, 0, 1, 1);
                render.wall3d(pointTex, x, z, x, z + step, -step / 2, step / 2, 0, 0, 1, 1);
                render.wall3d(pointTex, x + step, z + step, x + step, z, -step / 2, step / 2, 0, 0, 1, 1);
                render.wall3d(pointTex, x, z + step, x + step, z + step, -step / 2, step / 2, 0, 0, 1, 1);
            })

            line_renders.sort({|a, b|
                let len_a = a.from[0] * a.from[0] + a.from[1] * a.from[1];
                let len_b = b.from[0] * b.from[0] + b.from[1] * b.from[1];

                if len_a < len_b {
                    return -1
                } else if len_a == len_b {
                    return 0
                } else {
                    return 1
                }
            })

            line_renders.forEach({ |r|
                let step = 100 #512 * 2
                let x = r.from[0] * step
                let z = r.from[1] * step
                let x2 = r.to[0] * step
                let z2 = r.to[1] * step

                render.color(r.color)

                render.wall3d(whiteTex, x, z, x2, z2, -step / 2, step / 2, 0, 0, 1, 1);
                #[=
                render.wall3d(pointTex, x, z, x, z + step, -step / 2, step / 2, 0, 0, 1, 1);
                render.wall3d(pointTex, x + step, z + step, x + step, z, -step / 2, step / 2, 0, 0, 1, 1);
                render.wall3d(pointTex, x, z + step, x + step, z + step, -step / 2, step / 2, 0, 0, 1, 1);
                =]
            })

            render.flush()

            editor.draw(whiteTex, fontBits, imgShader)

            render.color(0xffffffff)
            # TODO: HUD y position needs to depend on aspect ratio :/
            let now = state.current_player_time(world)
            let second = state.TIME_IN_SECONDS - (now / state.SECOND) | 0
            let minute = (second / 60) | 0
            second %= 60;
            render.drawText(fontBits, whiteTex, minute + " " + second, -200, 250)

            render.flush()
        })
    }

    update()
}

window.onload := { ||
    startGame()
}
