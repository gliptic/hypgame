use state
use render

pub var draw
pub var paused

fn get_cell_name(cell) {
    if cell == state.CELL_FLOOR {
        return "FLOOR"
    } else if cell == state.CELL_BLOCK {
        return "BLOCK"
    }
}

pub fn start(world) {
    let cursor = [0, 0]
    var cursor_dir = true
    paused := true
    var editor_selected_cell = state.CELL_BLOCK

    let load_map = {
        let data = window.localStorage.getItem("hyp__map")
        if data {
            world.first_state.map := JSON.parse(data)
        }
    }

    load_map()
    state.world_reset(world)
    
    let save_map = {
        let data = JSON.stringify(world.first_state.map)
        window.localStorage.setItem("hyp__map", data)
        @debug console.log("saved", data)
    }

    var last_filename = "map.txt"

    let save_map_to_disk = {
        let data = JSON.stringify(world.first_state.map)

        var a = document.createElement("a")
        a.download := last_filename
        a.rel := "noopener"
        let blob = new File([data], last_filename)
        a.href := URL.createObjectURL(blob)
        setTimeout({ URL.revokeObjectURL(a.href) }, 40000)
        setTimeout({
            a.dispatchEvent(new MouseEvent("click"))
            @debug console.log("clicked")
        }, 0)
    }

    let load_map_from_disk = { |text|
        let map = JSON.parse(text)
        if map {
            world.first_state.map := map
        }
    }
    
    let drop_div = document.getElementById("d")
    drop_div.ondrop := { |ev|
        @debug console.log("drop", ev)

        if (ev.dataTransfer.items) {
            # Use DataTransferItemList interface to access the file(s)
            #console.log("DataTransferItemList")
            for i in 0..(ev.dataTransfer.items.length) {
                # If dropped items aren't files, reject them
                if (ev.dataTransfer.items[i].kind === "file") {
                    let file = ev.dataTransfer.items[i].getAsFile()
                    last_filename := file.name
                    #console.log("... file[" + i + "].name = " + file.name)
                    let reader = new FileReader()
                    reader.onload := { |rev|
                        load_map_from_disk(rev.target.result)
                    }
                    reader.readAsText(file)
                }
            }
        }

        return false
    }
    drop_div.ondragover := { |ev|
        return false
    }

    window.addEventListener("keydown", { |ev|
        #keys[ev.keyCode] := 1
        if ev.keyCode == 69 {
            # down
            cursor[1] += 1
        } else if ev.keyCode == 85 {
            cursor[1] -= 1
        }

        if ev.keyCode == 65 {
            cursor[0] -= 1
        } else if ev.keyCode == 79 {
            cursor[0] += 1
        }
        if ev.keyCode == 88 {
            cursor_dir := !cursor_dir
        }
        if ev.keyCode == 32 {
            let cur_cell = state.get_wall(world.first_state.map, cursor, cursor_dir)
            let draw_cell = if cur_cell == editor_selected_cell {
                state.CELL_FLOOR
            } else {
                editor_selected_cell
            }

            state.set_wall(
                world.first_state.map,
                cursor,
                cursor_dir,
                draw_cell)
        }
        if ev.keyCode >= 48 && ev.keyCode <= 58 {
            editor_selected_cell := state.CELL_FLOOR
        }
        if ev.keyCode == 9 {
            paused := !paused
        }
        if ev.keyCode == 76 {
            save_map()
            state.world_reset(world)
        }
        if ev.keyCode == 78 {
            save_map_to_disk()
        }
        #if ev.keyCode == 
        @debug console.log("key", ev.keyCode)
        return true
    })

    draw := { |whiteTex, fontBits, imgShader|
        # Map view/editor
        render.color(0xffffffff)
        render.setView2([1, 0])
        render.activateShader(imgShader)

        let scale_down = 100

        let drawWall = { |x, y, dir, width|
            let down = if !dir { -1 } else { width }
            let up = if !dir { 0 } else { -width }
            let right = if dir { 1 } else { width }
            let left = if dir { 0 } else { -width }

            render.wall3d(whiteTex,
                scale_down, 10 + x + left,
                scale_down, 10 + x + right,
                -y + up,
                -y + down, 0, 0, 1, 1);
        }

        # Editor bg
        render.color(0x7f000000)
        render.wall3d(whiteTex,
            scale_down, 10 + 0,
            scale_down, 10 + 0 + state.W,
            -0,
            -0 - state.H, 0, 0, 1, 1);

        render.color(0xff00ff00)
        drawWall(cursor[0], cursor[1], cursor_dir, 0.1)

        for my in 0..32 {
            for mx in 0..32 {
                let step = 1
                
                let st = world.first_state
                let down = state.get_wall(st.map, [mx, my], false)
                let right = state.get_wall(st.map, [mx, my], true)

                let width = 0.05
                #[=
                render.wall3d(whiteTex,
                    step * 80, 1000 + mx * step,
                    step * 80, 1000 + mx * step + step,
                    -3000 + my * step,
                    -3000 + my * step + step, 0, 0, 1, 1);
                =]
                render.color(0xffffffff)

                if down == state.CELL_BLOCK {
                    drawWall(mx, my, false, width)
                }
                if right == state.CELL_BLOCK {
                    drawWall(mx, my, true, width)
                }
            }
        }

        render.color(0xff0000ff)

        let player_pos = world.current_player_state.pos
        let player_width = 0.1

        render.wall3d(whiteTex,
            scale_down, 10 + player_pos[0] - player_width,
            scale_down, 10 + player_pos[0] + player_width,
            -player_pos[1] - player_width,
            -player_pos[1] + player_width, 0, 0, 1, 1);

        # coords here are *10 the map coords
        render.drawText(fontBits, whiteTex, get_cell_name(editor_selected_cell), 100, 10)
    }
}